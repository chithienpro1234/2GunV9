<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Army Battle 2D - OOP Refactored Final</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* --- GIỮ NGUYÊN CSS CŨ --- */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; font-family: 'Segoe UI', Tahoma, sans-serif; touch-action: none; }
        body { background-color: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; overflow: hidden; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 900px; max-height: 500px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); border-radius: 5px; overflow: hidden; background: #000; }
        @media (max-width: 900px) { #game-container { width: 100%; height: 65vh; max-height: none; border-radius: 0; position: absolute; top: 50%; transform: translateY(-50%); } }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #ui-layer>* { pointer-events: auto; }
        
        #minimap-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); backdrop-filter: blur(3px); z-index: 19; transition: opacity 0.2s; }
        #minimap-container { position: absolute; top: 15px; right: 15px; width: 150px; background-color: rgba(0, 0, 0, 0.8); border: 2px solid #555; border-radius: 4px; z-index: 20; pointer-events: none; overflow: visible; transition: opacity 0.3s; }
        #minimapCanvas { width: 100%; height: 100%; display: block; border-radius: 2px; }
        #btn-close-map { display: none; position: absolute; top: -10px; right: -10px; width: 24px; height: 24px; background: #d32f2f; color: white; border: 2px solid #fff; border-radius: 50%; z-index: 21; cursor: pointer; justify-content: center; align-items: center; font-size: 12px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
        #btn-toggle-map { display: none; position: absolute; top: 60px; right: 15px; z-index: 18; background: rgba(0, 0, 0, 0.8); color: #ddd; border: 1px solid #666; border-radius: 6px; padding: 5px 10px; font-size: 10px; font-weight: bold; cursor: pointer; text-transform: uppercase; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
        #btn-toggle-map.active { background: #004d40; color: #fff; border-color: #009688; }
        
        #pause-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 101; color: white; }
        #pause-menu.hidden { display: none; }

        .hud-top-left { position: absolute; top: 15px; left: 15px; display: flex; flex-direction: column; gap: 8px; width: 220px; }
        .stats-row { display: flex; gap: 4px; }
        .stat-box { background-color: rgba(40, 50, 60, 0.85); color: white; padding: 5px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; flex: 1; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); white-space: nowrap; }
        .bar-container { display: flex; flex-direction: column; gap: 5px; background-color: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 6px; }
        .bar-row { display: flex; align-items: center; gap: 8px; }
        .bar-label { color: #ddd; font-size: 10px; width: 50px; font-weight: bold; }
        .progress-track { flex-grow: 1; height: 6px; background: #444; border-radius: 3px; overflow: hidden; border: 1px solid #666; position: relative; }
        .progress-fill { height: 100%; border-radius: 3px; transition: width 0.1s; }
        .fill-move { background: linear-gradient(90deg, #00c853, #69f0ae); width: 100%; }
        .fill-power { background: linear-gradient(90deg, #ff6d00, #ffd180); width: 0%; }
        .chat-history-box { margin-top: 5px; background-color: rgba(20, 20, 20, 0.6); border-radius: 6px; padding: 8px; height: 95px; display: none; flex-direction: column; justify-content: flex-end; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.1); pointer-events: none; }
        .chat-item { font-size: 11px; color: #eee; margin-bottom: 3px; line-height: 1.4; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8); animation: fadeIn 0.3s ease-out; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-name { font-weight: bold; color: #ff5722; margin-right: 5px; }
        .chat-system { color: #d500f9; font-weight: bold; font-style: italic; }
        .chat-finish { color: #d5e216; font-weight: bold; text-transform: uppercase; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        
        .turn-badge { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(20, 20, 20, 0.95); color: #ff9800; padding: 6px 20px; border-radius: 12px; border: 1px solid #555; font-weight: bold; font-size: 13px; text-transform: uppercase; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.6); z-index: 10; display: flex; flex-direction: column; align-items: center; gap: 4px; white-space: nowrap; min-width: 140px; }
        
        .pause-text-btn { cursor: pointer; color: #ffeb3b; font-size: 10px; font-weight: bold; padding: 1px 5px; border-radius: 3px; background: rgba(255, 255, 255, 0.1); border: 1px solid #555; transition: all 0.2s; }
        .pause-text-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: #ffeb3b; }
        .pause-text-btn:active { transform: scale(0.95); }

        .timer-warning { color: #ff3d00 !important; animation: pulse-red 0.5s infinite alternate; }
        @keyframes pulse-red { from { opacity: 1; } to { opacity: 0.5; } }
        .controls-area { position: absolute; bottom: 20px; left: 20px; transition: opacity 0.3s ease; }
        .d-pad { display: grid; grid-template-columns: 45px 45px 45px; grid-template-rows: 45px 45px 45px; gap: 5px; }
        .d-btn { width: 100%; height: 100%; background: rgba(60, 70, 80, 0.8); border: 1px solid #555; border-radius: 8px; color: white; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 20px; -webkit-tap-highlight-color: transparent; }
        .d-btn:active { background: #888; transform: scale(0.95); }
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 3; }
        
        .action-container { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; align-items: center; gap: 12px; transition: opacity 0.3s ease; }
        .skills-row { display: flex; gap: 10px; }
        .skill-btn { width: 45px; height: 45px; border-radius: 50%; background: #333; border: 2px solid #555; color: #777; display: flex; justify-content: center; align-items: center; font-size: 18px; cursor: not-allowed; position: relative; transition: all 0.2s; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5); }
        .skill-btn.unlocked { background: #004d40; border-color: #009688; color: #fff; cursor: pointer; }
        .skill-btn.active { background: #00bfa5; border-color: #fff; box-shadow: 0 0 15px #00e676; transform: scale(1.1); }
        .skill-btn.used { background: #222 !important; border-color: #444 !important; color: #555 !important; cursor: not-allowed !important; opacity: 0.5; box-shadow: none !important; transform: none !important; }
        .skill-info { position: absolute; top: -35px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); color: #fff; font-size: 9px; padding: 3px 6px; border-radius: 4px; white-space: nowrap; opacity: 0; transition: opacity 0.2s; pointer-events: none; border: 1px solid #555; z-index: 100; text-align: center; }
        .skill-btn:active .skill-info, .skill-btn.active .skill-info { opacity: 1; }
        
        .btn-fire { width: 85px; height: 85px; border-radius: 50%; background: linear-gradient(135deg, #d32f2f, #b71c1c); border: 3px solid rgba(255, 255, 255, 0.8); color: white; font-weight: bold; font-size: 16px; cursor: pointer; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); outline: none; -webkit-tap-highlight-color: transparent; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; }
        .btn-fire:active { transform: scale(0.9); background: #b71c1c; }
        .btn-fire.skill-active-mode { background: linear-gradient(135deg, #6200ea, #b388ff); box-shadow: 0 0 15px #d500f9, 0 0 30px #aa00ff, inset 0 0 10px rgba(255, 255, 255, 0.5); border: 2px solid #fff; animation: pulse-skill 0.8s infinite alternate; font-size: 18px; text-shadow: 0 0 5px #fff; }
        @keyframes pulse-skill { from { transform: scale(1); box-shadow: 0 0 15px #d500f9; } to { transform: scale(1.05); box-shadow: 0 0 30px #d500f9, 0 0 10px #fff; } }
        
        #start-menu, #end-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.92); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: white; }
        #end-screen.hidden, #start-menu.hidden { display: none; }
        .menu-title { font-size: 28px; margin-bottom: 30px; color: #fff; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #fff; text-align: center; }
        .diff-btn { width: 220px; padding: 15px; margin: 10px 0; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; transition: transform 0.2s, filter 0.2s; color: white; text-transform: uppercase; box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5); position: relative; }
        .diff-btn:active { transform: translateY(4px); box-shadow: none; }
        .diff-btn.easy { background: linear-gradient(to right, #4CAF50, #8BC34A); }
        .diff-btn.hard { background: linear-gradient(to right, #FF9800, #FF5722); }
        .diff-btn.impossible { background: linear-gradient(to right, #6200EA, #D500F9); border: 2px solid #fff; box-shadow: 0 0 15px #D500F9; }
        .diff-info { font-size: 11px; font-weight: normal; display: block; margin-top: 3px; opacity: 0.9; text-transform: none; }
        #end-msg { font-size: 40px; margin-bottom: 20px; text-transform: uppercase; }
        button.restart-btn { padding: 10px 25px; font-size: 18px; border-radius: 25px; background: linear-gradient(45deg, #ff4b1f, #ff9068); color: white; border: none; cursor: pointer; }
        
        /* --- STYLE CHO MENU CHỌN XE --- */
        .nav-btn { background: rgba(255,255,255,0.1); border: 1px solid #777; color: white; border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .nav-btn:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        .nav-btn:active { transform: scale(0.95); }

        @media (max-width: 600px) { 
            .menu-title { font-size: 22px; } .diff-btn { width: 80%; font-size: 16px; } 
            .hud-top-left { width: 175px; gap: 4px; } .stat-box { padding: 4px 4px; font-size: 9px; } .bar-label { width: 40px; font-size: 9px; } 
            .chat-history-box { height: auto; min-height: 20px; padding: 5px; margin-top: 3px; background-color: rgba(20, 20, 20, 0.6); justify-content: flex-end; } .chat-history-box .chat-item:not(:nth-last-child(-n+2)) { display: none; } .chat-item { font-size: 11px; margin-bottom: 3px; line-height: 1.3; } 
            .turn-badge { left: auto; right: 15px; top: 15px; transform: none; font-size: 10px; padding: 5px 15px; } 
            #minimap-overlay.show { display: block; } 
            #minimap-container { display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 20px rgba(0, 0, 0, 0.8); border: 2px solid #fff; pointer-events: auto; } #minimap-container.show { display: block; } 
            #btn-close-map { display: flex; } 
            #btn-toggle-map { display: block; top: 75px; right: 15px; } 
            .controls-area { bottom: 15px; left: 10px; } .d-pad { grid-template-columns: 32px 32px 32px; grid-template-rows: 32px 32px 32px; gap: 2px; } .d-btn { font-size: 14px; border-radius: 5px; } 
            .action-container { bottom: 15px; right: 10px; gap: 8px; } .skills-row { gap: 6px; } .skill-btn { width: 35px; height: 35px; font-size: 14px; } .btn-fire { width: 55px; height: 55px; font-size: 12px; border-width: 2px; } .btn-fire.skill-active-mode { font-size: 12px; } 
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="start-menu">
            <h1 class="menu-title">CHỌN ĐỘ KHÓ</h1>
            <button class="diff-btn easy" onclick="startGame('EASY')">Dễ vỗn lài<span class="diff-info">Danh cho mấy con gà</span></button>
            <button class="diff-btn hard" onclick="startGame('HARD')">Khó đó ní<span class="diff-info">Dân Pro chưa chắc thắng</span></button>
            <button class="diff-btn impossible" onclick="startGame('IMPOSSIBLE')">Bất lực<span class="diff-info">Tuyệt vọng đến cùng cực</span></button>
            
            <div id="tank-select-menu" style="display:none; text-align:center; margin-top:10px; width: 100%;">
                <h2 style="color:#fff; font-size:18px; margin-bottom:15px; letter-spacing: 1px;">CHỌN CHIẾN XA</h2>
                <div style="display:flex; align-items:center; justify-content:center; gap:15px;">
                    <button class="nav-btn" onclick="changeTank(-1)" style="padding:15px; font-weight:bold; font-size: 18px;">&lt;</button>
                    
                    <div style="width:220px; height:130px; background:rgba(0,0,0,0.5); border:2px solid #555; border-radius:10px; display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 10px;">
                        <div id="tank-preview-name" style="color:#ff9800; font-weight:bold; font-size:18px; text-transform: uppercase;">TANK NAME</div>
                        <div id="tank-preview-desc" style="color:#aaa; font-size:11px; padding:5px; font-style: italic;">Description</div>
                    </div>
            
                    <button class="nav-btn" onclick="changeTank(1)" style="padding:15px; font-weight:bold; font-size: 18px;">&gt;</button>
                </div>
                <button class="restart-btn" style="margin-top:25px; box-shadow: 0 0 15px rgba(255, 75, 31, 0.5);" onclick="confirmStartGame()">VÀO TRẬN</button>
            </div>

            <p style="margin-top: 20px; color: #777; font-size: 12px;">(Chọn để bật âm thanh & bắt đầu)</p>
        </div>

        <div id="end-screen" class="hidden">
            <h1 id="end-msg">YOU WIN</h1>
            <button class="restart-btn" onclick="location.reload()">Chơi lại</button>
        </div>

        <div id="ui-layer">
            
            <div id="pause-menu" class="hidden">
                <h1 class="menu-title">TẠM DỪNG</h1>
                <button class="restart-btn" onclick="togglePause()">Tiếp Tục</button>
                <button class="restart-btn" style="margin-top: 15px; background: #555;" onclick="location.reload()">Thoát Game</button>
            </div>

            <div id="minimap-overlay"></div>

            <div id="minimap-container">
                <div id="btn-close-map"><i class="fas fa-times"></i></div>
                <canvas id="minimapCanvas"></canvas>
            </div>

            <div id="btn-toggle-map">XEM MAP</div>

            <div class="turn-badge" id="turn-badge">
                <div style="border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 4px; margin-bottom: 4px; width: 100%; display: flex; justify-content: space-between; align-items: center;">
                    <span id="mode-text" style="color:#aaa; letter-spacing: 1px; font-size: 10px;">DỄ</span>
                    <span id="btn-pause-text" class="pause-text-btn">DỪNG</span>
                </div>
                <div style="display: flex; gap: 10px; font-size: 10px; align-items: center;">
                    <span>Lượt: <span id="turn-text" style="color: #00d2ff">BẠN</span></span>
                    <span style="color: #555">|</span>
                    <span id="timer-text" style="color:#fff; min-width: 25px; text-align:center;">20s</span>
                </div>
            </div>

            <div class="hud-top-left">
                <div class="stats-row">
                    <div class="stat-box">Gió: <span id="wind-val" class="text-blue" style="margin-left:4px; color:#00d2ff">0</span></div>
                    <div class="stat-box">Góc: <span id="angle-val" class="text-yellow" style="margin-left:4px; color:#ffd700">0°</span></div>
                    <div class="stat-box">HP: <span id="hp-val" class="text-red" style="margin-left:4px; color:#ff5252">100</span></div>
                </div>
                <div class="bar-container">
                    <div class="bar-row">
                        <span class="bar-label">Mana</span>
                        <div class="progress-track">
                            <div class="progress-fill fill-move" id="move-bar"></div>
                        </div>
                    </div>
                    <div class="bar-row">
                        <span class="bar-label">Lực</span>
                        <div class="progress-track">
                            <div class="progress-fill fill-power" id="power-bar"></div>
                        </div>
                    </div>
                </div>

                <div class="chat-history-box" id="chat-history"></div>
            </div>

            <div class="controls-area">
                <div class="d-pad">
                    <div class="d-btn btn-up" id="btn-up"><i class="fas fa-caret-up"></i></div>
                    <div class="d-btn btn-left" id="btn-left"><i class="fas fa-caret-left"></i></div>
                    <div class="d-btn btn-right" id="btn-right"><i class="fas fa-caret-right"></i></div>
                    <div class="d-btn btn-down" id="btn-down"><i class="fas fa-caret-down"></i></div>
                </div>
            </div>

            <div class="action-container">
                <div class="skills-row">
                    <div class="skill-btn" id="btn-skill-1">
                        <i class="fas fa-meteor"></i>
                        <div class="skill-info">Skill 1</div>
                    </div>
                    <div class="skill-btn" id="btn-skill-2">
                        <i class="fas fa-crosshairs"></i>
                        <div class="skill-info">Skill 2</div>
                    </div>
                    <div class="skill-btn" id="btn-skill-3">
                        <i class="fas fa-shield-alt"></i>
                        <div class="skill-info">Khiên (< 40% HP)</div>
                    </div>
                    <div class="skill-btn" id="btn-skill-4">
                        <i class="fas fa-parachute-box"></i>
                        <div class="skill-info">Tiếp Tế (< 50% HP)</div>
                    </div>
                </div>
                <button class="btn-fire" id="btn-fire">BẮN</button>
            </div>
        </div>
    </div>
    <script>
        // --- CONSTANTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');

        let VIEWPORT_W = container.clientWidth;
        let SCREEN_H = container.clientHeight;
        let GAME_SCALE = 1;
        const MAP_WIDTH = 1200;
        const MAP_HEIGHT = 1000;
        const GROUND_Y = MAP_HEIGHT - 220;
        const BRIDGE_START = 150;
        const BRIDGE_END = 1050;
        const GRAVITY = 0.15;
        const SPEED_CONSTANT = 0.11;
        const MAX_MOVE_ENERGY = 100;
        const WIND_FACTOR = 0.005;

        // --- GLOBAL GAME STATE ---
        let cameraX = 0;
        let cameraY = MAP_HEIGHT - SCREEN_H;
        let isDragging = false;
        let startDragX = 0, startDragY = 0;
        let initialCameraX = 0, initialCameraY = 0;

        let gameState = 'WAITING';
        let isPaused = false; 
        let turn = 'PLAYER';
        let wind = 0;
        
        let player = null; 
        let ai = null;

        let charging = false;
        let currentPower = 0;
        let keys = {};
        let activeSkill = null;

        let skill1Used = false;
        let skill2Used = false;
        let skill3Used = false;
        let playerShieldActive = false;
        
        let skill4Uses = 2; 
        let supplyDrops = [];
        let activeSupplyDrop = null; 

        let aiAccuracyMin = 0.6;
        let aiAccuracyMax = 0.7;
        let turnDuration = 20;
        let timeLeft = 0;
        let timerInterval = null;
        let currentModeName = 'DỄ';
        let lastAiMessage = "";
        let playerLandedHit = false;

        let clouds = [];
        let bullets = [];
        let particles = [];
        let floatingTexts = [];
        let waterOffset = 0;

        // --- UI ELEMENTS ---
        const elWind = document.getElementById('wind-val');
        const elAngle = document.getElementById('angle-val');
        const elHp = document.getElementById('hp-val');
        const elMoveBar = document.getElementById('move-bar');
        const elPowerBar = document.getElementById('power-bar');
        const elTurnText = document.getElementById('turn-text');
        const elModeText = document.getElementById('mode-text');
        const elTimerText = document.getElementById('timer-text');
        const elChatHistory = document.getElementById('chat-history');
        const elEndScreen = document.getElementById('end-screen');
        const elEndMsg = document.getElementById('end-msg');
        const btnSkill1 = document.getElementById('btn-skill-1');
        const btnSkill2 = document.getElementById('btn-skill-2');
        const btnSkill3 = document.getElementById('btn-skill-3');
        const btnSkill4 = document.getElementById('btn-skill-4');
        const btnFire = document.getElementById('btn-fire');
        const startMenu = document.getElementById('start-menu');
        const btnPauseText = document.getElementById('btn-pause-text');
        const pauseMenu = document.getElementById('pause-menu');

        const mmCanvas = document.getElementById('minimapCanvas');
        const mmCtx = mmCanvas.getContext('2d');
        const mmContainer = document.getElementById('minimap-container');
        const mmOverlay = document.getElementById('minimap-overlay');
        const btnToggleMap = document.getElementById('btn-toggle-map');
        const btnCloseMap = document.getElementById('btn-close-map');
        
        const MINIMAP_WIDTH = 150;
        const MAP_SCALE = MINIMAP_WIDTH / MAP_WIDTH;
        const MINIMAP_HEIGHT = MAP_HEIGHT * MAP_SCALE;
        
        const dpr = window.devicePixelRatio || 1;
        mmCanvas.width = MINIMAP_WIDTH * dpr;
        mmCanvas.height = MINIMAP_HEIGHT * dpr;
        mmCanvas.style.width = MINIMAP_WIDTH + 'px';
        mmCanvas.style.height = MINIMAP_HEIGHT + 'px';
        document.getElementById('minimap-container').style.height = MINIMAP_HEIGHT + 'px';

        // ==========================================
        // === OOP CLASSES: BULLETS & TANKS (REFACTORED) ===
        // ==========================================

        // --- BASE BULLET ---
        // --- BASE BULLET ---
        class BaseBullet {
            constructor(x, y, angle, power, damage, gravity = GRAVITY, windResist = 1.0) {
                const rad = angle * Math.PI / 180;
                this.x = x + Math.cos(rad) * 44;
                this.y = (y - 14) - Math.sin(rad) * 44;
                this.vx = Math.cos(rad) * (power * SPEED_CONSTANT);
                this.vy = -Math.sin(rad) * (power * SPEED_CONSTANT);
                this.damage = damage;         
                this.gravityVal = gravity;    
                this.windFactor = windResist; 
                this.isDead = false;          
                this.history = [];
                this.historyMax = 10;
            }

            // === [NEW] GETTER CHO CAMERA (OOP) ===
            // Mặc định: Theo dõi nếu chưa chết VÀ nằm trong vùng bản đồ hợp lý
            get shouldCameraTrack() {
                return !this.isDead && this.y > -500;
            }

            update() {
                this.vx += wind * WIND_FACTOR * this.windFactor;
                this.vy += this.gravityVal;
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -100 || this.x > MAP_WIDTH + 100 || this.y > MAP_HEIGHT) {
                    this.isDead = true;
                }
                
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.historyMax) this.history.shift();
            }

            draw(ctx) { }

            calculateDamage(target) {
                let baseDmg = (this.damage > 0) ? this.damage : Math.floor(Math.random() * 10 + 20);
                let angleBonus = 1.0;
                if (this.vy > 8) { angleBonus = 1.25; } else if (this.vy > 6) { angleBonus = 1.15; }
                return Math.floor(baseDmg * angleBonus);
            }

            onHit(target) {
                createExplosion(this.x, this.y, 20, 'fire');
            }

            handleCollision(target, shooter) {
                SoundManager.playExplosion();

                let finalDmg = this.calculateDamage(target);
                if (shooter && shooter.damageBuff) finalDmg *= 2;

                if (target === shooter) {
                    showFloatingText("TỰ HỦY!", target.x, target.y - 70, '#ff0000');
                } else if (this.vy > 6 || this.isSuperCharged) {
                    showFloatingText("CHÍ MẠNG!", target.x, target.y - 80, '#ff3d00');
                }

                target.takeDamage(finalDmg);
                let randomOffset = (Math.random() - 0.5) * 40;
                showFloatingText(`-${finalDmg}`, target.x + randomOffset, target.y - 50 + randomOffset, 'red');

                this.onHit(target);
            }
        }

        // --- Artillery BULLET ---
        class ArtilleryBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal) {
                super(x, y, angle, power, 0, GRAVITY, 1.0); 
                this.windEffect = windVal * WIND_FACTOR; 
                this.isPotentialHighShot = (angle >= 40 && angle <= 140) && (power > 90);
                this.isSuperCharged = false;
                this.timer = 0;
            }

            update() {
                this.timer++;
                super.update();
                if (this.isPotentialHighShot && this.vy > 0 && !this.isSuperCharged) {
                    this.isSuperCharged = true;
                }
                if (this.timer % 2 === 0) {
                    let pType = this.isSuperCharged ? 'fire' : 'spark';
                    particles.push(new Particle(this.x, this.y, pType, { 
                        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 0.5, size: Math.random() * 2 + 1 
                    }));
                }
            }

            calculateDamage(target) {
                let baseDmg = Math.floor(Math.random() * 10 + 20);
                let angleBonus = 1.0;
                if (this.isSuperCharged) { angleBonus = 1.3; } 
                else { if (this.vy > 8) angleBonus = 1.25; else if (this.vy > 6) angleBonus = 1.15; }
                return Math.floor(baseDmg * angleBonus);
            }

            onHit(target) {
                let size = this.isSuperCharged ? 40 : 20;
                createExplosion(this.x, this.y, size, 'fire');
            }

            draw(ctx) {
                ctx.save();
                if (this.history.length > 2) {
                    ctx.beginPath(); 
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    for (let i = 1; i < this.history.length; i++) { ctx.lineWidth = 1 + (i / this.history.length) * 4; ctx.lineTo(this.history[i].x, this.history[i].y); }
                    let grad = ctx.createLinearGradient(this.history[0].x, this.history[0].y, this.x, this.y);
                    if (this.isSuperCharged) { grad.addColorStop(0, 'rgba(255, 50, 0, 0)'); grad.addColorStop(1, 'rgba(255, 200, 0, 0.8)'); } else { grad.addColorStop(0, 'rgba(255, 255, 255, 0)'); grad.addColorStop(1, 'rgba(255, 255, 255, 0.6)'); }
                    ctx.strokeStyle = grad; ctx.stroke();
                }
                ctx.translate(this.x, this.y); 
                let rot = Math.atan2(this.vy, this.vx); ctx.rotate(rot);
                ctx.shadowBlur = this.isSuperCharged ? 20 : 10; ctx.shadowColor = this.isSuperCharged ? '#ff3d00' : '#ffa000'; ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = this.isSuperCharged ? '#ffeb3b' : '#fff'; 
                ctx.beginPath(); let stretch = Math.min(2.0, 1.0 + Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 0.05); ctx.scale(stretch, 0.6); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill(); 
                ctx.restore();
            }
        }

        // --- Machine BULLET ---
        class MachineGunBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, sequenceIndex) {
                super(x, y, angle, power * 1.0, 0, 0.12, 0.4);
                this.oriX = this.x; this.oriY = this.y;
                this.activationDelay = sequenceIndex * 6;
                if (this.activationDelay > 0) { this.y = -5000; }
                this.damage = 0; 
            }

            // === [NEW] GHI ĐÈ GETTER ===
            // Nếu đang delay (chưa bắn) -> KHÔNG theo dõi
            get shouldCameraTrack() {
                if (this.activationDelay > 0) return false;
                return super.shouldCameraTrack; // Gọi logic mặc định của cha
            }

            update() {
                if (this.activationDelay > 0) {
                    this.activationDelay--;
                    if (this.activationDelay <= 0) { this.x = this.oriX; this.y = this.oriY; SoundManager.playShoot(); }
                    return;
                }
                super.update();
            }
            
            onHit(target) { createExplosion(this.x, this.y, 20, 'fire'); }

            draw(ctx) {
                if (this.y < -1000) return;
                ctx.save(); ctx.translate(this.x, this.y); let rot = Math.atan2(this.vy, this.vx); ctx.rotate(rot);
                let tailGrad = ctx.createLinearGradient(0, 0, -30, 0); tailGrad.addColorStop(0, "rgba(255, 215, 0, 0.9)"); tailGrad.addColorStop(1, "rgba(255, 69, 0, 0)");
                ctx.fillStyle = tailGrad; ctx.beginPath(); ctx.moveTo(0, 2); ctx.lineTo(-30, 0); ctx.lineTo(0, -2); ctx.fill();
                ctx.shadowBlur = 10; ctx.shadowColor = '#FFD700';
                let bulletGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 6); bulletGrad.addColorStop(0, "#FFFFFF"); bulletGrad.addColorStop(0.4, "#FFFF00"); bulletGrad.addColorStop(1, "#FF8C00");
                ctx.fillStyle = bulletGrad; ctx.beginPath(); ctx.ellipse(0, 0, 10, 3.5, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); ctx.restore();
            }
        }

        // --- Laser BULLET (UPDATED) ---
        class LaserBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, type = 'NORMAL', targetObj = null) {
                super(x, y, angle, power, 0); // Dummy init, will override props below
                this.type = type; 
                this.isDead = false;
                this.targetObj = targetObj; 
                this.history = [];

                if (type === 'SATELLITE') {
                    this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.speed = 0; this.life = 1000; this.color = '#d500f9';
                }
                else if (type === 'TRIGGER') {
                    const rad = angle * Math.PI / 180; const spawnDist = 60;
                    this.x = x + Math.cos(rad) * spawnDist; this.y = (y - 14) - Math.sin(rad) * spawnDist;
                    this.speed = 25; this.vx = Math.cos(rad) * this.speed; this.vy = -Math.sin(rad) * this.speed;
                    this.damage = 10; this.width = 3; this.color = '#fff';
                }
                else if (type === 'AUTO_BEAM') {
                    this.x = x; this.y = y; this.speed = 30; 
                    if (targetObj) {
                        let dx = targetObj.x - x; let dy = (targetObj.y - 20) - y; let dist = Math.sqrt(dx*dx + dy*dy);
                        this.vx = (dx/dist) * this.speed; this.vy = (dy/dist) * this.speed;
                    } else { this.vx = 0; this.vy = 0; }
                    this.damage = 75; this.width = 10; this.color = '#d500f9';
                }
                else {
                    const rad = angle * Math.PI / 180; 
                    if (type === 'SPLIT_CHILD') { this.x = x; this.y = y; } 
                    else { const spawnDist = 65; this.x = x + Math.cos(rad) * spawnDist; this.y = (y - 14) - Math.sin(rad) * spawnDist; }
                    
                    this.state = 'UP'; this.speed = 12; 

                    if (type === 'SPLIT_CHILD') { 
                        // === [UPDATED] GIẢM DAMAGE TỪ 50 XUỐNG 35 ===
                        this.damage = 35; this.width = 2; this.color = '#00e676'; 
                    } else { 
                        this.damage = Math.floor(Math.random() * 15 + 40); this.width = 4; this.color = '#00e5ff'; 
                    }

                    if (type !== 'SPLIT_CHILD') {
                        let flightPower = power * 1.3; 
                        let simVx = Math.cos(rad) * flightPower * 0.15; let simVy = Math.sin(rad) * flightPower * 0.15; 
                        let timeToPeak = simVy / GRAVITY; if (timeToPeak < 5) timeToPeak = 10;
                        let windShift = windVal * timeToPeak * 0.8; 
                        this.peakX = this.x + (simVx * timeToPeak) + windShift;
                        this.peakY = this.y - (simVy * timeToPeak) + (0.5 * GRAVITY * timeToPeak * timeToPeak);
                        if (this.peakY < -400) this.peakY = -400; 
                        this.landX = this.peakX + (simVx * timeToPeak) + windShift; this.landY = GROUND_Y + 50; 
                        this.setTarget(this.peakX, this.peakY);
                    } else { this.state = 'DOWN'; }
                }
                this.history = [{x: this.x, y: this.y}];
            }

            // === [NEW] GHI ĐÈ GETTER ===
            // Nếu là Vệ Tinh -> KHÔNG bao giờ theo dõi
            get shouldCameraTrack() {
                if (this.type === 'SATELLITE') return false;
                return super.shouldCameraTrack;
            }

            setTarget(tx, ty) {
                this.targetX = tx; this.targetY = ty;
                let dx = tx - this.x; let dy = ty - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy); if (dist === 0) dist = 1;
                this.vx = (dx / dist) * this.speed; this.vy = (dy / dist) * this.speed;
            }

            update() {
                if (this.type === 'SATELLITE') return;
                if (this.type === 'TRIGGER') {
                    this.x += this.vx; this.y += this.vy; this.history.push({x: this.x, y: this.y}); if(this.history.length > 10) this.history.shift();
                    for (let i = 0; i < bullets.length; i++) {
                        let b = bullets[i];
                        if (b.type === 'SATELLITE' && !b.isDead) {
                            if (Math.hypot(this.x - b.x, this.y - b.y) < 40) {
                                this.isDead = true; b.isDead = true; SoundManager.playExplosion(); createExplosion(b.x, b.y, 30, 'shockwave');
                                let enemy = ai; bullets.push(new LaserBullet(b.x, b.y, 0, 0, 0, 'AUTO_BEAM', enemy)); showFloatingText("KẾT NỐI!", b.x, b.y - 50, '#d500f9'); return;
                            }
                        }
                    }
                    if (this.x < -200 || this.x > MAP_WIDTH + 200 || this.y > MAP_HEIGHT + 200) this.isDead = true;
                    return;
                }
                if (this.type === 'AUTO_BEAM') {
                    this.x += this.vx; this.y += this.vy; this.history.push({x: this.x, y: this.y}); if(this.history.length > 20) this.history.shift();
                    if (this.x < -200 || this.x > MAP_WIDTH + 200 || this.y > MAP_HEIGHT + 200) this.isDead = true; return;
                }

                this.history.push({x: this.x, y: this.y}); if (this.history.length > 30) this.history.shift(); 
                this.x += this.vx; this.y += this.vy;

                if (this.state === 'UP') {
                    let distToPeak = Math.hypot(this.x - this.peakX, this.y - this.peakY);
                    if (distToPeak <= this.speed) {
                        this.x = this.peakX; this.y = this.peakY;
                        if (this.type === 'SPLIT_PARENT') { this.splitBullets(this.peakX, this.peakY); this.isDead = true; return; }
                        this.state = 'DOWN'; this.setTarget(this.landX, this.landY);
                    }
                } 
                if (this.x < -200 || this.x > MAP_WIDTH + 200 || this.y > MAP_HEIGHT + 100) this.isDead = true;
            }

            splitBullets(ox, oy) {
                SoundManager.playShoot(); createExplosion(ox, oy, 15, 'spark');
                let tx = this.landX; let ty = this.landY; let spread = [-300, -100, 100, 300];
                spread.forEach((offset) => {
                    let child = new LaserBullet(ox, oy, 0, 0, 0, 'SPLIT_CHILD'); child.setTarget(tx + offset, ty); child.history = [{x: ox, y: oy}]; bullets.push(child);
                });
            }
            
            calculateDamage(target) { return this.damage; }
            onHit(target) { createExplosion(this.x, this.y, (this.type==='AUTO_BEAM'?40:20), 'spark'); }

            draw(ctx) {
                ctx.save();
                if (this.type === 'SATELLITE') {
                    ctx.translate(this.x, this.y); ctx.translate(0, Math.sin(Date.now() / 300) * 5); this.drawDiamondShape(ctx, 2.0); ctx.restore(); return;
                }
                if (this.history.length < 2) { ctx.restore(); return; }
                if (this.type === 'AUTO_BEAM') {
                    ctx.shadowBlur = 20; ctx.shadowColor = '#d500f9'; ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath(); ctx.moveTo(this.history[0].x, this.history[0].y); for (let i = 1; i < this.history.length; i++) ctx.lineTo(this.history[i].x, this.history[i].y); ctx.lineTo(this.x, this.y);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.stroke(); ctx.strokeStyle = '#d500f9'; ctx.lineWidth = 10; ctx.globalAlpha = 0.5; ctx.stroke(); ctx.restore(); return;
                }
                if (this.state === 'DOWN' && this.type === 'NORMAL') {
                    ctx.save(); if (this.peakX !== undefined && this.peakY !== undefined) { ctx.translate(this.peakX, this.peakY); this.drawDiamondShape(ctx, 1.2); } ctx.restore();
                }
                ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath(); ctx.moveTo(this.history[0].x, this.history[0].y); for (let i = 1; i < this.history.length; i++) ctx.lineTo(this.history[i].x, this.history[i].y); ctx.lineTo(this.x, this.y);
                let grad = ctx.createLinearGradient(this.history[0].x, this.history[0].y, this.x, this.y); grad.addColorStop(0, 'rgba(255, 255, 255, 0)'); grad.addColorStop(1, this.color);
                ctx.strokeStyle = grad; ctx.lineWidth = this.width; ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.width, 0, Math.PI*2); ctx.fill(); ctx.restore();
            }

            drawDiamondShape(ctx, scale) {
                ctx.scale(scale, scale); const colorLight = '#4fc3f7'; const colorDark = '#0288d1'; const colorBorder = '#e1f5fe';
                ctx.beginPath(); ctx.moveTo(-12, -2); ctx.lineTo(12, -2); ctx.lineTo(0, 16); ctx.closePath(); ctx.fillStyle = colorDark; ctx.fill(); ctx.lineWidth = 1; ctx.strokeStyle = colorBorder; ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, -10); ctx.lineTo(8, -10); ctx.lineTo(12, -2); ctx.lineTo(-12, -2); ctx.closePath(); ctx.fillStyle = colorLight; ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, -10); ctx.lineTo(8, -10); ctx.lineTo(4, -2); ctx.lineTo(-4, -2); ctx.closePath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.fill();
                ctx.beginPath(); ctx.moveTo(-12, -2); ctx.lineTo(0, 16); ctx.moveTo(12, -2); ctx.lineTo(0, 16); ctx.moveTo(0, -2); ctx.lineTo(0, 16); ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.stroke();
            }
        }

        
        class BoomerangBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, damage, isSkill2 = false) {
                // windResist thấp (0.3)
                super(x, y, angle, power, damage, GRAVITY, 0.3); 
                
                this.rotAngle = 0; 
                this.isSkill2 = isSkill2;
                this.initialAngle = angle;
                this.lifeTime = 0;

                this.accelX = 0;         
                this.gravityVal = GRAVITY;
                this.turnStartFrame = 0; // Thời điểm bắt đầu quay xe

                // --- CẤU HÌNH VẬT LÝ ---

                // 1. GÓC CAO (> 70 và < 110): Bay lơ lửng (giữ nguyên logic cũ bạn đã ưng)
                if (this.initialAngle > 70 && this.initialAngle < 110) {
                    this.gravityVal = GRAVITY * 0.35; 
                    this.accelX = 0; 
                } 
                
                // 2. GÓC THẤP (30-70 & 110-150): MÓC CÂU GẮT RA SAU LƯNG
                else {
                    // A. TĂNG TỐC ĐỘ BAN ĐẦU (1.3 lần)
                    // Để đạn vọt qua đầu địch và đạt độ cao lớn hơn
                    this.vx *= 1.3;
                    this.vy *= 1.3;

                    // B. CẤU HÌNH GIAI ĐOẠN
                    // Bay thẳng trong 55 frame (khoảng 1 giây) -> Đủ để bay qua map
                    this.turnStartFrame = 55; 

                    // Lực giật về RẤT MẠNH (0.25) thay vì nhẹ nhàng (0.09) như cũ
                    // Để tạo khúc cua gắt ở cuối
                    let hookStrength = 0.25; 

                    let isShootingRight = (this.initialAngle < 90);
                    if (isShootingRight) {
                        this.pendingAccelX = -hookStrength; // Sẽ áp dụng sau
                    } else {
                        this.pendingAccelX = hookStrength;  // Sẽ áp dụng sau
                    }
                }

                this.historyMax = 35; // Đuôi dài hơn nữa
            }

            update() {
                // 1. Gió
                this.vx += wind * WIND_FACTOR * this.windFactor;
                
                // 2. Trọng lực
                this.vy += this.gravityVal;

                this.lifeTime++;

                // 3. LOGIC "BAY QUA ĐẦU RỒI MỚI QUAY LẠI"
                // Nếu là góc thấp và đã đến lúc "quay xe"
                if (this.pendingAccelX && this.lifeTime > this.turnStartFrame) {
                    // Cộng lực giật mạnh vào vận tốc
                    this.vx += this.pendingAccelX;
                }

                // 4. Cập nhật vị trí
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -300 || this.x > MAP_WIDTH + 300 || this.y > MAP_HEIGHT) {
                    this.isDead = true;
                }
                
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.historyMax) this.history.shift();

                this.rotAngle += 0.5; 
            }

            draw(ctx) {
                if (this.history.length < 2) return;
                ctx.save();
                
                // VẼ ĐUÔI
                ctx.beginPath();
                ctx.moveTo(this.history[0].x, this.history[0].y);
                for (let i = 1; i < this.history.length - 1; i++) {
                    let p0 = this.history[i];
                    let p1 = this.history[i+1];
                    let midX = (p0.x + p1.x) / 2;
                    let midY = (p0.y + p1.y) / 2;
                    ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
                }
                ctx.lineTo(this.x, this.y);
                
                let trailGrad = ctx.createLinearGradient(this.history[0].x, this.history[0].y, this.x, this.y);
                trailGrad.addColorStop(0, 'rgba(118, 255, 3, 0)');   
                trailGrad.addColorStop(0.5, 'rgba(118, 255, 3, 0.3)');
                trailGrad.addColorStop(1, 'rgba(118, 255, 3, 0.9)'); 
                
                ctx.lineCap = 'round';
                ctx.lineWidth = this.isSkill2 ? 8 : 4; 
                ctx.strokeStyle = trailGrad;
                ctx.stroke();

                // VẼ THÂN
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotAngle);
                ctx.shadowBlur = 15; ctx.shadowColor = '#76ff03';

                ctx.beginPath();
                ctx.fillStyle = this.isSkill2 ? '#ccff90' : '#76ff03'; 
                ctx.strokeStyle = '#33691e'; ctx.lineWidth = 2;
                const outerRadius = 14; const innerRadius = 5; const spikes = 3;
                for (let i = 0; i < spikes * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const a = (Math.PI * i) / spikes;
                    const x = Math.cos(a) * r; const y = Math.sin(a) * r;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
                ctx.restore();
            }
            
            calculateDamage(target) { let dmg = super.calculateDamage(target); if (this.isSkill2) dmg *= 2; return dmg; }

            onHit(target) {
                createExplosion(this.x, this.y, 25, 'smoke'); 
                for(let i=0; i<12; i++) {
                    particles.push(new Particle(this.x, this.y, 'spark', { vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 0.7, size: 3 }));
                }
            }
        }

        // --- BASE TANK SYSTEM ---
        class BaseTank {
            constructor(x, color, name, isAI) {
                this.x = x; this.y = GROUND_Y - 14; this.color = color; this.name = name; this.isAI = isAI;
                this.hp = 100; this.maxHp = 100; this.angle = isAI ? 135 : 45; this.hitTimer = 0;
                this.isParachuting = false; this.moveEnergy = MAX_MOVE_ENERGY; this.damageBuff = false;
                this.extraShot = false; this.scale = 1.0; this.w = 48; 
            }
            
            onTurnEnd() {
                // Mặc định không làm gì
            }

            getPhysics() { return { gravity: GRAVITY, powerMulti: 1.0 }; }

            // === [LOGIC MỚI] TÍNH TOÁN QUỸ ĐẠO CHUẨN ===
            calculateTrajectory(power, windVal, stepsLimit = 20) {
                const rad = this.angle * Math.PI / 180;
                const phys = this.getPhysics();
                let windResist = 1.0; 
                
                // Điểm xuất phát
                let sx = Math.cos(rad) * 44;
                let sy = -10 - Math.sin(rad) * 44;
                
                // Tốc độ ban đầu
                let speed = power * SPEED_CONSTANT * phys.powerMulti;
                let vx = Math.cos(rad) * speed;
                let vy = -Math.sin(rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;

                // Xử lý stepsLimit: Nếu truyền số thì lấy số, nếu truyền boolean thì tự gán
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : (stepsLimit ? 300 : 20);

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist;
                    vy += phys.gravity;
                    curX += vx;
                    curY += vy;
                    points.push({x: curX, y: curY});

                    // Chỉ dừng khi chạm đất NẾU đang vẽ dây dài (Skill 2)
                    // Nếu vẽ dây ngắn gợi ý (steps nhỏ), ta cho phép vẽ xuyên đất một chút để không bị mất nét
                    if (steps > 50 && (this.y + curY > GROUND_Y + 50)) break;
                }

                return { type: 'curve', points: points };
            }
            // ============================================

            move(dir) {
                if (this.isParachuting) return;
                if (!this.isAI && this.moveEnergy <= 0) return;
                this.x += dir * 2; SoundManager.playMove(); this.y = (GROUND_Y - 14) + (Math.random() > 0.7 ? (Math.random() - 0.5) : 0);
                if (!this.isAI) this.moveEnergy -= 1; this.x = Math.max(BRIDGE_START + 25, Math.min(BRIDGE_END - 25, this.x));
                this.checkSupplyPickup(); 
            }
            adjustAngle(d) { if (this.isParachuting) return; this.angle = Math.max(10, Math.min(170, this.angle + d)); }
            takeDamage(dmg) { if (this.scale > 1.0) dmg = Math.floor(dmg * 0.8); this.hp -= dmg; this.hitTimer = 20; }
            checkSupplyPickup() {
                if (this.isAI) return;
                for (let i = supplyDrops.length - 1; i >= 0; i--) {
                    let s = supplyDrops[i];
                    if (!s.isFalling && Math.abs(this.x - s.x) < 30) {
                        createExplosion(s.x, s.y, 15, 'spark');
                        if (s.type === 'HEAL') { this.hp = Math.min(this.maxHp, this.hp + s.val); showFloatingText(`+${s.val} HP`, this.x, this.y - 60, '#00e676'); addChatLog("Bạn", "Đã hồi máu!");}
                        else if (s.type === 'DAMAGE') { this.damageBuff = true; showFloatingText("SÁT THƯƠNG x2!", this.x, this.y - 60, '#ff3d00'); addChatLog("Bạn", "Nhặt đạn cường hoá!");}
                        else if (s.type === 'GIANT') { this.scale = 1.5; this.maxHp += 50; this.hp += 50; showFloatingText("KHỔNG LỒ HOÁ!", this.x, this.y - 80, '#d500f9'); addChatLog("Bạn", "Biến thành khổng lồ!");}
                        else if (s.type === 'EXTRA_TURN') { this.extraShot = true; showFloatingText("+1 LƯỢT BẮN", this.x, this.y - 60, '#2979ff'); addChatLog("Bạn", "Thêm lượt bắn!");}
                        supplyDrops.splice(i, 1);
                    }
                }
            }
            updateParachute() {
                if (this.y < GROUND_Y - 14) { this.y += 2.5; this.x += Math.sin(Date.now() / 200) * 0.8; this.x = Math.max(BRIDGE_START + 25, Math.min(BRIDGE_END - 25, this.x)); return false; } 
                else { if (this.isParachuting) { this.y = GROUND_Y - 14; this.isParachuting = false; SoundManager.playLand(); return true; } return true; }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.scale, this.scale);
                if (this.hitTimer > 0) { this.hitTimer--; ctx.shadowBlur = 25; ctx.shadowColor = (this.hitTimer % 6 < 3) ? '#ff3d00' : '#ffffff'; }
                if (this.damageBuff) { ctx.shadowBlur = 15; ctx.shadowColor = '#ff3d00'; }
                this.drawTracks(ctx); this.drawBody(ctx); this.drawTurret(ctx); if (this.isParachuting) this.drawParachute(ctx);
                ctx.restore(); if (!this.isParachuting) this.drawHPBar(ctx);
            }
            drawTracks(ctx) {
                ctx.fillStyle = '#222'; ctx.beginPath(); ctx.moveTo(-24, 14); ctx.lineTo(24, 14); ctx.lineTo(28, 4); ctx.lineTo(-28, 4); ctx.fill();
                ctx.fillStyle = '#444'; for (let i = 0; i < 6; i++) { ctx.beginPath(); ctx.arc(-20 + (i * 8), 8.5, 3.5, 0, Math.PI * 2); ctx.fill(); }
                ctx.strokeStyle = '#111'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-28, 4); ctx.lineTo(28, 4); ctx.stroke();
            }
            drawBody(ctx) { ctx.fillStyle = this.color; ctx.fillRect(-22, -4, 44, 8); ctx.strokeStyle = '#000'; ctx.lineWidth = 3; ctx.strokeRect(-22, -4, 44, 8); }
            drawTurret(ctx) { ctx.beginPath(); ctx.arc(0, -4, 14, Math.PI, 0); ctx.fillStyle = this.color; ctx.fill(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3; ctx.stroke(); }
            drawParachute(ctx) {
                ctx.save(); let sway = Math.sin(Date.now() / 250) * 0.15; ctx.rotate(sway); const anchorX = 0; const anchorY = -22; const canopyY = -70; const canopyW = 40;
                ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.lineTo(-canopyW, canopyY); ctx.moveTo(anchorX, anchorY); ctx.lineTo(0, canopyY - 5); ctx.moveTo(anchorX, anchorY); ctx.lineTo(canopyW, canopyY); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.stroke();
                ctx.beginPath(); ctx.arc(0, canopyY, canopyW, Math.PI, 0); ctx.fillStyle = this.color || '#fff'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke(); 
                ctx.beginPath(); ctx.moveTo(0, canopyY); ctx.lineTo(0, canopyY - 35); ctx.lineWidth = 1; ctx.stroke(); ctx.restore();
            }
            drawHPBar(ctx) {
                const hpYOffset = 45 * this.scale; const hpX = this.x - 25; const hpY = this.y - hpYOffset; 
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(hpX, hpY, 50, 6); const hpP = Math.max(0, this.hp / this.maxHp); ctx.fillStyle = hpP < 0.3 ? '#ff5252' : '#00e676'; ctx.fillRect(hpX, hpY, 50 * hpP, 6);
                if (this.damageBuff) { ctx.fillStyle = '#ff3d00'; ctx.font = 'bold 12px Arial'; ctx.fillText('DMG x2', this.x + 30, hpY); }
                if (this.extraShot) { ctx.fillStyle = '#2979ff'; ctx.font = 'bold 12px Arial'; ctx.fillText('+1 TURN', this.x - 60, hpY); }
            }
            fireNormal(power, windVal) { return []; }
            fireSkill1(power, windVal) { return []; }
            fireSkill2(power, windVal) { return []; }
        }

        // --- 3. ARTILLERY GUN TANK ---
        class ArtilleryGunTank extends BaseTank {
            drawBody(ctx) {
                super.drawBody(ctx); ctx.fillStyle = this.color; ctx.fillRect(-22, -4, 44, 12); ctx.strokeStyle = '#00000091'; ctx.strokeRect(-22, -4, 44, 12); ctx.beginPath(); ctx.arc(0, -4, 16, Math.PI, 0); ctx.fill(); ctx.stroke();
            }
            drawTurret(ctx) {
                ctx.save(); ctx.translate(0, -10); ctx.rotate(-this.angle * Math.PI / 180); 
                if (this === player && activeSkill === 1) { const blink = Math.floor(Date.now() / 100) % 2 === 0; ctx.fillStyle = blink ? '#ff1744' : '#b71c1c'; ctx.shadowBlur = 15; ctx.shadowColor = '#ff1744'; } else { ctx.fillStyle = '#FFD700'; ctx.shadowBlur = 0; }
                ctx.fillRect(0, -6, 14, 12); 
                if (this === player && activeSkill === 1) { let grad = ctx.createLinearGradient(14, -4, 44, -4); grad.addColorStop(0, '#ff5252'); grad.addColorStop(1, '#d50000'); ctx.fillStyle = grad; } else { let grad = ctx.createLinearGradient(14, -4, 44, -4); grad.addColorStop(0, '#ccc'); grad.addColorStop(1, '#999'); ctx.fillStyle = grad; }
                ctx.fillRect(14, -4, 30, 8); ctx.strokeRect(14, -4, 30, 8); ctx.restore(); 
            }
            createMuzzleFlash(offsetAngle) { SoundManager.playShoot(); const rad = (this.angle + offsetAngle) * Math.PI / 180; createExplosion(this.x + Math.cos(rad) * 44, (this.y - 14) - Math.sin(rad) * 44, 10, 'smoke'); }
            fireNormal(power, windVal) { this.createMuzzleFlash(0); return [new ArtilleryBullet(this.x, this.y, this.angle, power, windVal)]; }
            fireSkill1(power, windVal) { this.createMuzzleFlash(0); return [new ArtilleryBullet(this.x, this.y, this.angle, power, windVal), new ArtilleryBullet(this.x, this.y, this.angle - 5, power, windVal), new ArtilleryBullet(this.x, this.y, this.angle + 5, power, windVal)]; }
            fireSkill2(power, windVal) { this.createMuzzleFlash(0); return [new ArtilleryBullet(this.x, this.y, this.angle, power, windVal)]; }
        }

        // --- 4. MachineGunTank ---
        class MachineGunTank extends BaseTank {
            getPhysics() { return { gravity: 0.12, powerMulti: 1.0 }; }
            adjustAngle(d) { if (this.isParachuting) return; this.angle = Math.max(0, Math.min(180, this.angle + d)); }
            
            drawBody(ctx) { super.drawBody(ctx); ctx.fillStyle = this.color; ctx.fillRect(-22, -4, 44, 12); ctx.strokeStyle = '#000'; ctx.lineWidth = 3; ctx.strokeRect(-22, -4, 44, 12); ctx.beginPath(); ctx.arc(0, -4, 16, Math.PI, 0); ctx.fill(); ctx.stroke(); }
            
            drawTurret(ctx) {
                ctx.save(); ctx.translate(0, -10); ctx.rotate(-this.angle * Math.PI / 180); ctx.lineWidth = 3; ctx.strokeStyle = '#000';
                ctx.fillStyle = this.color; ctx.fillRect(-2, -8, 18, 16); ctx.strokeRect(-2, -8, 18, 16);
                ctx.fillStyle = '#333'; ctx.fillRect(16, -6, 32, 5); ctx.strokeRect(16, -6, 32, 5); ctx.fillRect(16, 1, 32, 5); ctx.strokeRect(16, 1, 32, 5);
                ctx.fillStyle = '#000'; ctx.fillRect(45, -7, 6, 7); ctx.fillRect(45, 0, 6, 7);
                if (this === player && activeSkill === 1) { ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000'; ctx.strokeStyle = '#ff0000'; ctx.strokeRect(16, -6, 32, 5); ctx.strokeRect(16, 1, 32, 5); } ctx.restore();
            }
            
            // === [LOGIC MỚI] OVERRIDE VỚI WIND RESIST 0.4 ===
            calculateTrajectory(power, windVal, stepsLimit = 20) {
                const rad = this.angle * Math.PI / 180;
                const phys = this.getPhysics(); 
                
                let windResist = 0.4; // Đạn súng máy chịu gió ít
                
                let sx = Math.cos(rad) * 44;
                let sy = -10 - Math.sin(rad) * 44;
                let speed = power * SPEED_CONSTANT * phys.powerMulti;
                
                let vx = Math.cos(rad) * speed;
                let vy = -Math.sin(rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : (stepsLimit ? 300 : 20);

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist; 
                    vy += phys.gravity;
                    curX += vx;
                    curY += vy;
                    points.push({x: curX, y: curY});
                    
                    if (steps > 50 && (this.y + curY > GROUND_Y + 50)) break;
                }

                return { type: 'curve', points: points };
            }
            // ================================================

            createMuzzleFlash(offsetAngle) { const rad = (this.angle + offsetAngle) * Math.PI / 180; createExplosion(this.x + Math.cos(rad) * 50, (this.y - 14) - Math.sin(rad) * 50, 4, 'spark'); }
            fireNormal(power, windVal) { this.createMuzzleFlash(0); let bullets = []; for (let i = 0; i < 3; i++) { let angleDev = (Math.random() - 0.5) * 6; let b = new MachineGunBullet(this.x, this.y, this.angle + angleDev, power, windVal, i); b.damage = Math.floor(Math.random() * 5) + 8; bullets.push(b); } return bullets; }
            fireSkill1(power, windVal) { this.createMuzzleFlash(0); let bullets = []; for (let i = 0; i < 6; i++) { let angleDev = (Math.random() - 0.5) * 8; let b = new MachineGunBullet(this.x, this.y, this.angle + angleDev, power, windVal, i); b.damage = Math.floor(Math.random() * 5) + 8; bullets.push(b); } return bullets; }
            fireSkill2(power, windVal) { return this.fireNormal(power, windVal); }
        }

        // --- Laser Tank (REFACTORED CLEANUP) ---
        class LaserTank extends BaseTank {
            
            // === [NEW] TỰ DỌN DẸP VỆ TINH KHI HẾT LƯỢT ===
            onTurnEnd() {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    if (bullets[i].type === 'SATELLITE') {
                        bullets.splice(i, 1);
                    }
                }
            }

            drawBody(ctx) {
                this.drawTracks(ctx); ctx.fillStyle = '#263238'; ctx.fillRect(-24, -6, 48, 14); ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 2; ctx.strokeRect(-24, -6, 48, 14);
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(-15, -6); ctx.lineTo(-5, 0); ctx.lineTo(-15, 6); ctx.fill();
            }
            drawTurret(ctx) {
                ctx.save(); ctx.translate(0, -10); ctx.rotate(-this.angle * Math.PI / 180);
                if (this === player && activeSkill) { ctx.shadowBlur = 10; ctx.shadowColor = (activeSkill === 2) ? '#d500f9' : '#00e5ff'; }
                ctx.fillStyle = '#37474f'; ctx.fillRect(-10, -10, 20, 20); ctx.strokeStyle = '#00e5ff'; ctx.strokeRect(-10, -10, 20, 20);
                ctx.fillStyle = '#222'; ctx.fillRect(10, -4, 35, 8); ctx.fillStyle = this.color; ctx.fillRect(10, -9, 30, 3); ctx.fillRect(10, 6, 30, 3);
                ctx.fillStyle = '#e0f7fa'; ctx.fillRect(10, -1, 35, 2); ctx.restore();
            }
            // [OVERRIDE]
            calculateTrajectory(power, windVal, isLongPath = false) {
                // Nếu là Skill 2: Trả về đường thẳng (Raycast)
                if (activeSkill === 2) {
                    const rad = this.angle * Math.PI / 180;
                    let start = { x: Math.cos(rad)*44, y: -14 - Math.sin(rad)*44 };
                    let end = { x: Math.cos(rad)*200, y: -14 - Math.sin(rad)*200 };
                    return { type: 'line', points: [start, end] };
                }
                
                // Nếu bắn thường hoặc Skill 1: Dùng logic vật lý cơ bản của cha
                return super.calculateTrajectory(power, windVal, isLongPath);
            }
            createMuzzleFlash(offsetAngle) { SoundManager.playShoot(); const rad = (this.angle + offsetAngle) * Math.PI / 180; createExplosion(this.x + Math.cos(rad) * 44, (this.y - 14) - Math.sin(rad) * 44, 15, 'spark'); }
            fireNormal(power, windVal) { this.createMuzzleFlash(0); return [new LaserBullet(this.x, this.y, this.angle, power, windVal, 'NORMAL')]; }
            fireSkill1(power, windVal) { this.createMuzzleFlash(0); return [new LaserBullet(this.x, this.y, this.angle, power, windVal, 'SPLIT_PARENT')]; }
            deploySatellite() {
                for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i].type === 'SATELLITE') bullets.splice(i, 1); }
                let satX = this.x + 60; let satY = this.y - 120; bullets.push(new LaserBullet(satX, satY, 0, 0, 0, 'SATELLITE'));
                SoundManager.playShoot(); createExplosion(satX, satY, 10, 'spark');
            }
            fireSkill2(power, windVal) { this.createMuzzleFlash(0); return [new LaserBullet(this.x, this.y, this.angle, power, windVal, 'TRIGGER')]; }
        }

       class BoomerangTank extends BaseTank {
            constructor(x, color, name, isAI) {
                super(x, color, name, isAI);
                this.angle = 45; 
                if (!isAI && ai) { if (this.x > ai.x) { this.scale = -1; this.angle = 135; } }
            }

            adjustAngle(d) {
                if (this.isParachuting) return;
                this.angle = Math.max(30, Math.min(150, this.angle + d));
            }

            drawBody(ctx) {
                super.drawBody(ctx);
                ctx.fillStyle = '#33691e'; ctx.fillRect(-22, -4, 44, 12); ctx.strokeStyle = '#1b5e20'; ctx.strokeRect(-22, -4, 44, 12);
                ctx.beginPath(); ctx.arc(0, -4, 16, Math.PI, 0); ctx.fillStyle = this.color; ctx.fill(); ctx.stroke();
            }

            drawTurret(ctx) {
                ctx.save(); ctx.translate(0, -10);
                let drawAngle = this.angle; if (this.scale < 0) drawAngle = 180 - this.angle;
                ctx.rotate(-drawAngle * Math.PI / 180);
                if (this === player && activeSkill === 2) { ctx.shadowBlur = 15; ctx.shadowColor = '#76ff03'; }
                ctx.fillStyle = '#558b2f'; ctx.fillRect(0, -8, 10, 16);
                ctx.fillStyle = '#76ff03'; ctx.fillRect(10, -10, 28, 4); ctx.strokeRect(10, -10, 28, 4);
                ctx.fillStyle = '#76ff03'; ctx.fillRect(10, 6, 28, 4); ctx.strokeRect(10, 6, 28, 4);
                ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(25, -6); ctx.lineTo(25, 6); ctx.closePath(); ctx.fillStyle = '#ccff90'; ctx.fill();
                ctx.restore();
            }

            // === TÍNH TOÁN QUỸ ĐẠO KHỚP LOGIC 2 GIAI ĐOẠN ===
            calculateTrajectory(power, windVal, stepsLimit = 20) {
                const rad = this.angle * Math.PI / 180;
                let sx = Math.cos(rad) * 44;
                let sy = -10 - Math.sin(rad) * 44;
                let speed = power * SPEED_CONSTANT; 

                let vx = Math.cos(rad) * speed;
                let vy = -Math.sin(rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : (stepsLimit ? 300 : 20);

                // --- CẤU HÌNH ---
                let currentGravity = GRAVITY;
                let windResist = 0.3;
                
                let pendingAccelX = 0;
                let turnStartFrame = 0;

                // 1. GÓC CAO (Tạc đạn)
                if (this.angle > 70 && this.angle < 110) {
                    currentGravity = GRAVITY * 0.35;
                    pendingAccelX = 0;
                } 
                // 2. GÓC THẤP (Móc câu sau lưng)
                else {
                    // Tăng tốc độ đầu vào (cho khớp Bullet)
                    vx *= 1.3;
                    vy *= 1.3;

                    turnStartFrame = 55; // Delay dài
                    let hookStrength = 0.25; // Lực giật mạnh

                    if (this.angle < 90) pendingAccelX = -hookStrength;
                    else pendingAccelX = hookStrength;
                }

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist;
                    
                    // Logic quay xe gắt
                    if (pendingAccelX !== 0 && i > turnStartFrame) {
                        vx += pendingAccelX;
                    }
                    
                    vy += currentGravity;

                    curX += vx;
                    curY += vy;
                    points.push({x: curX, y: curY});

                    if (steps > 50 && (this.y + curY > GROUND_Y + 50)) break;
                }

                return { type: 'curve', points: points };
            }

            createMuzzleFlash(offsetAngle) {
                SoundManager.playShoot();
                const rad = (this.angle + offsetAngle) * Math.PI / 180;
                createExplosion(this.x + Math.cos(rad) * 44, (this.y - 14) - Math.sin(rad) * 44, 10, 'smoke'); 
            }

            fireNormal(power, windVal) {
                this.createMuzzleFlash(0);
                let dmg = Math.floor(Math.random() * 10 + 30);
                return [new BoomerangBullet(this.x, this.y, this.angle, power, windVal, dmg)];
            }

            fireSkill1(power, windVal) {
                this.createMuzzleFlash(0);
                let bullets = [];
                let offsets = [-4, 0, 4]; // 3 tia lệch nhau
                
                offsets.forEach(off => {
                    // [CẬP NHẬT] Tăng Damage từ (20-25) lên (35-45)
                    // Tổng 3 viên nếu trúng hết sẽ là > 100 damage (Rất mạnh)
                    let dmg = Math.floor(Math.random() * 10 + 60);
                    
                    bullets.push(new BoomerangBullet(this.x, this.y, this.angle + off, power, windVal, dmg));
                });
                return bullets;
            }
           

            fireSkill2(power, windVal) {
                this.createMuzzleFlash(0);
                let baseDmg = Math.floor(Math.random() * 10 + 30); 
                return [new BoomerangBullet(this.x, this.y, this.angle, power, windVal, baseDmg, true)];
            }
        }
        
        // ==========================================
        // === TANK ROSTER & MENU CONFIG ===
        // ==========================================
        const TANK_ROSTER = [
            { id: 'artillery', name: 'PHÁO KÍCH', desc: 'Sát thương cao, đạn cầu vồng cổ điển.', className: ArtilleryGunTank, color: '#e53935', skill1Name: '3 Đạn (< 80% HP)', skill2Name: 'Lộ Sight (< 60% HP)' },
            { id: 'machinegun', name: 'SÚNG MÁY', desc: 'Bắn liên thanh, đạn bay nhanh.', className: MachineGunTank, color: '#FFD700', skill1Name: 'Sấy 6 Viên (< 80% HP)', skill2Name: 'Lộ Sight (< 60% HP)' },
            { id: 'laser', name: 'XE LASER', desc: 'Đạn chậm, tách hạt nổ trên không.', className: LaserTank, color: '#d500f9', skill1Name: 'Mưa Laser (Tách khi rơi)', skill2Name: 'Tia Hủy Diệt (x2 DMG)' },
            // Thêm vào TANK_ROSTER
            { 
                id: 'boomerang', 
                name: 'BOOMERANG', 
                desc: 'Đạn bay quỹ đạo móc câu. Kỹ năng cao.', 
                className: BoomerangTank, 
                color: '#76ff03', // Màu xanh nõn chuối
                skill1Name: 'Tam Giác Mạch (3 Tia)', 
                skill2Name: 'Móc Tử Thần (x2 DMG + Aim)' 
            }
        ];

        let selectedTankIndex = 0;
        let selectedDifficulty = 'EASY';

        function updateTankPreview() {
            const tankInfo = TANK_ROSTER[selectedTankIndex];
            document.getElementById('tank-preview-name').innerText = tankInfo.name;
            document.getElementById('tank-preview-desc').innerText = tankInfo.desc;
        }

        function changeTank(dir) {
            selectedTankIndex += dir;
            if (selectedTankIndex < 0) selectedTankIndex = TANK_ROSTER.length - 1;
            if (selectedTankIndex >= TANK_ROSTER.length) selectedTankIndex = 0;
            updateTankPreview();
        }

        // ==========================================
        // === GAME LOGIC & HELPERS ===
        // ==========================================

        function toggleMap(show) { if (show) { mmContainer.classList.add('show'); mmOverlay.classList.add('show'); btnToggleMap.classList.add('active'); drawMinimap(); } else { mmContainer.classList.remove('show'); mmOverlay.classList.remove('show'); btnToggleMap.classList.remove('active'); } }
        btnToggleMap.addEventListener('click', (e) => { e.stopPropagation(); const isShowing = mmContainer.classList.contains('show'); toggleMap(!isShowing); });
        btnCloseMap.addEventListener('click', (e) => { e.stopPropagation(); toggleMap(false); });
        mmOverlay.addEventListener('click', (e) => { e.stopPropagation(); toggleMap(false); });
        btnToggleMap.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); const isShowing = mmContainer.classList.contains('show'); toggleMap(!isShowing); });
        btnCloseMap.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleMap(false); });
        mmOverlay.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleMap(false); });

        function togglePause() {
            if (gameState !== 'PLAYING' && gameState !== 'PAUSED' && gameState !== 'INTRO') return;
            isPaused = !isPaused;
            if (isPaused) { if(gameState === 'INTRO') { pauseMenu.classList.remove('hidden'); btnPauseText.innerText = "TIẾP"; return; } gameState = 'PAUSED'; pauseMenu.classList.remove('hidden'); btnPauseText.innerText = "TIẾP"; SoundManager.stopCharge(); SoundManager.stopWind(); SoundManager.stopBGM(); } 
            else { 
                if(player.isParachuting) { gameState = 'INTRO'; pauseMenu.classList.add('hidden'); btnPauseText.innerText = "DỪNG"; SoundManager.playWind(); return; } 
                gameState = 'PLAYING'; pauseMenu.classList.add('hidden'); btnPauseText.innerText = "DỪNG"; SoundManager.playBGM();
            }
        }
        btnPauseText.addEventListener('click', (e) => { e.stopPropagation(); togglePause(); });
        btnPauseText.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); togglePause(); });

        function drawMinimap() {
            if (window.innerWidth <= 600 && !mmContainer.classList.contains('show')) return;
            mmCtx.save(); mmCtx.scale(dpr, dpr); mmCtx.clearRect(0, 0, MINIMAP_WIDTH, MINIMAP_HEIGHT);
            mmCtx.fillStyle = 'rgba(135, 206, 235, 0.2)'; mmCtx.fillRect(0, 0, MINIMAP_WIDTH, MINIMAP_HEIGHT);
            mmCtx.fillStyle = '#555'; mmCtx.fillRect(BRIDGE_START * MAP_SCALE, GROUND_Y * MAP_SCALE, (BRIDGE_END - BRIDGE_START) * MAP_SCALE, 6);
            for (let bx = BRIDGE_START + 100; bx < BRIDGE_END; bx += 200) { mmCtx.fillRect((bx - 10) * MAP_SCALE, GROUND_Y * MAP_SCALE, 20 * MAP_SCALE, (MAP_HEIGHT - GROUND_Y) * MAP_SCALE); }
            mmCtx.fillStyle = 'rgba(2, 136, 209, 0.5)'; mmCtx.fillRect(0, (GROUND_Y + 50) * MAP_SCALE, MINIMAP_WIDTH, (MAP_HEIGHT - GROUND_Y) * MAP_SCALE);
            if (player) drawDot(player.x, player.y, '#00ff00', 4); if (ai && ai.hp > 0) drawDot(ai.x, ai.y, '#ff3d00', 4);
            supplyDrops.forEach(s => drawDot(s.x, s.y, '#fff', 3));
            mmCtx.strokeStyle = '#fff'; mmCtx.lineWidth = 1; mmCtx.strokeRect(cameraX * MAP_SCALE, cameraY * MAP_SCALE, VIEWPORT_W * MAP_SCALE, SCREEN_H * MAP_SCALE);
            mmCtx.restore();
        }
        function drawDot(x, y, color, radius) { mmCtx.beginPath(); mmCtx.arc(x * MAP_SCALE, y * MAP_SCALE, radius, 0, Math.PI * 2); mmCtx.fillStyle = color; mmCtx.fill(); }

        // --- SOUND MANAGER ---
        const SoundManager = {
            ctx: null, osc: null, gainNode: null, 
            init: function() { if (!this.ctx) { const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
            createNoiseBuffer: function() { if (!this.ctx) return null; const bSize = this.ctx.sampleRate * 2; const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate); const data = buf.getChannelData(0); for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1; return buf; },
            playShoot: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const noise = this.ctx.createBufferSource(); noise.buffer = this.createNoiseBuffer(); const nf = this.ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.setValueAtTime(1000, t); nf.frequency.exponentialRampToValueAtTime(100, t + 0.2); const ng = this.ctx.createGain(); ng.gain.setValueAtTime(0.5, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.2); noise.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination); noise.start(t); noise.stop(t + 0.3); },
            playExplosion: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const noise = this.ctx.createBufferSource(); noise.buffer = this.createNoiseBuffer(); const nf = this.ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.value = 800; const ng = this.ctx.createGain(); ng.gain.setValueAtTime(1.0, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.8); noise.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination); noise.start(t); noise.stop(t + 1); },
            playMove: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(40, t); const g = this.ctx.createGain(); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t + 0.1); osc.connect(g); g.connect(this.ctx.destination); osc.start(t); osc.stop(t + 0.1); },
            playLand: function() { 
                if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(80, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.2); const g = this.ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.2); osc.connect(g); g.connect(this.ctx.destination); osc.start(t); osc.stop(t + 0.2);
                const noise = this.ctx.createBufferSource(); noise.buffer = this.createNoiseBuffer(); const ng = this.ctx.createGain(); ng.gain.setValueAtTime(0.3, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.1); noise.connect(ng); ng.connect(this.ctx.destination); noise.start(t); noise.stop(t + 0.1);
            },
            playWind: function() {}, stopWind: function() {}, playBGM: function() {}, stopBGM: function() {},
            startCharge: function() { if (!this.ctx || this.osc) return; this.osc = this.ctx.createOscillator(); this.osc.type = 'triangle'; this.osc.frequency.setValueAtTime(200, this.ctx.currentTime); this.gainNode = this.ctx.createGain(); this.gainNode.gain.setValueAtTime(0.1, this.ctx.currentTime); this.osc.connect(this.gainNode); this.gainNode.connect(this.ctx.destination); this.osc.start(); },
            updateCharge: function(p) { if (this.osc && this.ctx) this.osc.frequency.setTargetAtTime(200 + (p * 4), this.ctx.currentTime, 0.05); },
            stopCharge: function() { if (this.osc) { this.gainNode.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1); this.osc.stop(this.ctx.currentTime + 0.1); this.osc = null; this.gainNode = null; } }
        };

        class Cloud {
            constructor() {
                this.x = Math.random() * MAP_WIDTH; this.y = Math.random() * (MAP_HEIGHT - 400); this.speed = (Math.random() * 0.2) + 0.1; this.size = (Math.random() * 0.5) + 0.5; this.parallaxX = 0.5; this.parallaxY = 0.2; this.puffs = [];
                for (let i = 0; i < 5 + Math.random() * 5; i++) { this.puffs.push({ x: (Math.random() - 0.5) * 60, y: (Math.random() - 0.5) * 30, r: 20 + Math.random() * 20 }); }
            }
            update() { this.x += this.speed + (wind * 0.05); if (this.x > MAP_WIDTH + 100) this.x = -100; else if (this.x < -100) this.x = MAP_WIDTH + 100; }
            draw() {
                let rx = this.x - (cameraX * this.parallaxX); let ry = this.y - (cameraY * this.parallaxY);
                if (rx > -100 && rx < VIEWPORT_W + 100 && ry > -100 && ry < SCREEN_H + 100) {
                    ctx.save(); ctx.translate(rx, ry); ctx.scale(this.size, this.size); ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath();
                    this.puffs.forEach(p => { ctx.moveTo(p.x, p.y); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); }); ctx.fill(); ctx.restore();
                }
            }
        }

        class SupplyDrop {
            constructor(x) {
                this.x = x; this.y = -200; this.isFalling = true; this.w = 30; this.h = 24; this.swayAngle = 0; this.intercepted = false; 
                const rand = Math.random();
                if (rand < 0.4) { this.type = 'HEAL'; this.val = (currentModeName === 'DỄ') ? 25 : (currentModeName === 'KHÓ' ? 20 : 15); this.color = '#00e676'; } 
                else if (rand < 0.65) { this.type = 'DAMAGE'; this.val = 2; this.color = '#ff3d00'; } 
                else if (rand < 0.85) { this.type = 'GIANT'; this.val = 1.5; this.color = '#d500f9'; } 
                else { this.type = 'EXTRA_TURN'; this.val = 1; this.color = '#2979ff'; }
            }
            update() {
                if (this.intercepted) return;
                if (this.isFalling) {
                    this.y += 2.0; this.swayAngle = Math.sin(Date.now() / 300) * 0.15; this.x += Math.sin(Date.now() / 400) * 0.5;
                    if (this.y >= GROUND_Y - this.h) { this.y = GROUND_Y - this.h; this.isFalling = false; SoundManager.playLand(); if (activeSupplyDrop === this) { activeSupplyDrop = null; showFloatingText("HÀNG ĐÃ ĐẾN!", this.x, this.y - 40, '#fff'); } }
                }
            }
            draw() {
                if (this.intercepted) return;
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.isFalling) {
                    ctx.save(); ctx.rotate(this.swayAngle); ctx.strokeStyle = '#eee'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-25, -40); ctx.moveTo(0, 0); ctx.lineTo(0, -42); ctx.moveTo(15, 0); ctx.lineTo(25, -40); ctx.stroke(); ctx.beginPath(); ctx.arc(0, -40, 30, Math.PI, 0); ctx.fillStyle = this.color; ctx.fill(); ctx.stroke(); ctx.restore();
                }
                ctx.fillStyle = '#333'; ctx.fillRect(-15, 0, 30, 24); ctx.strokeStyle = '#fff'; ctx.strokeRect(-15, 0, 30, 24); ctx.fillStyle = this.color; ctx.fillRect(-10, 5, 20, 14); 
                ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                let symbol = "+"; if(this.type === 'DAMAGE') symbol = "DMG"; if(this.type === 'GIANT') symbol = "BIG"; if(this.type === 'EXTRA_TURN') symbol = "1UP";
                ctx.fillText(symbol, 0, 16); ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, type, options = {}) {
                this.x = x; this.y = y; this.type = type;
                this.vx = options.vx || (Math.random() - 0.5) * 5; this.vy = options.vy || (Math.random() - 0.5) * 5;
                this.life = options.life || 1.0; this.decay = options.decay || 0.04; this.size = options.size || (4 + Math.random() * 4);
                this.friction = 0.95; this.gravity = 0.1;
                if (type === 'shockwave') { this.vx = 0; this.vy = 0; this.decay = 0.08; this.size = 1; this.maxSize = 40; }
            }
            update() {
                if (this.type !== 'shockwave') { this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; } else { this.size += 3; }
                this.life -= this.decay;
            }
            draw() {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                if (this.type === 'smoke') { ctx.fillStyle = '#666'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'fire') { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = `rgba(255, ${Math.floor(this.life * 200)}, 0, 1)`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'spark') { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'shockwave') { ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = `rgba(255, 200, 50, ${this.life})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.stroke(); }
                ctx.restore();
            }
        }

        function startTimer() {
            stopTimer(); timeLeft = turnDuration; updateUI();
            timerInterval = setInterval(() => {
                if (isPaused) return; 
                timeLeft--; updateUI();
                if (timeLeft <= 0) { stopTimer(); handlePlayerTimeout(); }
            }, 1000);
        }
        function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }
        function handlePlayerTimeout() {
            charging = false; SoundManager.stopCharge(); currentPower = 0; keys = {};
            turn = 'AI'; updateUI(); showFloatingText("HẾT GIỜ!", player.x, player.y - 60, '#ff3d00'); setTimeout(aiMovePhase, 1000);
        }

        function startGame(mode) {
            selectedDifficulty = mode;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.style.display = 'none');
            document.querySelector('.menu-title').innerText = "CHUẨN BỊ CHIẾN ĐẤU";
            document.getElementById('tank-select-menu').style.display = 'block';
            updateTankPreview();
        }

        function confirmStartGame() {
            SoundManager.init(); 
            startMenu.classList.add('hidden'); 
            gameState = 'INTRO';
            
            const PlayerClass = TANK_ROSTER[selectedTankIndex].className;
            const pColor = TANK_ROSTER[selectedTankIndex].color;
            player = new PlayerClass(250, pColor, 'Bạn', false);
            
            btnSkill1.querySelector('.skill-info').innerText = TANK_ROSTER[selectedTankIndex].skill1Name;
            btnSkill2.querySelector('.skill-info').innerText = TANK_ROSTER[selectedTankIndex].skill2Name;

            ai = new ArtilleryGunTank(950, '#1e88e5', 'Máy', true);

            player.y = -200; player.isParachuting = true;
            ai.y = -200; ai.isParachuting = true;
            player.x = 250 + (Math.random() - 0.5) * 50;
            ai.x = 950 + (Math.random() - 0.5) * 50;
            
            skill4Uses = 2; supplyDrops = [];

            let hpMulti = 1;
            if (selectedDifficulty === 'EASY') { aiAccuracyMin = 0.6; aiAccuracyMax = 0.7; hpMulti = 1; turnDuration = 25; currentModeName = 'DỄ'; }
            else if (selectedDifficulty === 'HARD') { aiAccuracyMin = 0.8; aiAccuracyMax = 0.9; hpMulti = 1.5; turnDuration = 20; currentModeName = 'KHÓ'; }
            else if (selectedDifficulty === 'IMPOSSIBLE') { aiAccuracyMin = 0.95; aiAccuracyMax = 0.95; hpMulti = 2.7; turnDuration = 15; currentModeName = 'BẤT LỰC'; }
            
            ai.maxHp = 100 * hpMulti; ai.hp = ai.maxHp;
            
            elChatHistory.innerHTML = ''; elChatHistory.style.display = 'none';
            chatPools = { 'DỄ': [], 'KHÓ': [], 'BẤT LỰC': [], 'MISS': [], 'FINISH': [] };
            
            updateUI();
        }

        function init() {
            resizeCanvas();
            for (let i = 0; i < 15; i++) clouds.push(new Cloud());
            randomWind();
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const containerW = container.clientWidth; const containerH = container.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(containerW * dpr); canvas.height = Math.floor(containerH * dpr);
            canvas.style.width = containerW + 'px'; canvas.style.height = containerH + 'px';
            if (window.innerWidth < 600) { GAME_SCALE = 0.75; } else { GAME_SCALE = 1.0; }
            VIEWPORT_W = containerW / GAME_SCALE; SCREEN_H = containerH / GAME_SCALE;
            clampCamera();
        }

        window.addEventListener('resize', resizeCanvas);
        function clampCamera() {
            if (cameraX < 0) cameraX = 0;
            if (cameraX > MAP_WIDTH - VIEWPORT_W) cameraX = MAP_WIDTH - VIEWPORT_W;
            if (cameraY < 0) cameraY = 0;
            if (cameraY > MAP_HEIGHT - SCREEN_H) cameraY = MAP_HEIGHT - SCREEN_H;
            if (MAP_WIDTH < VIEWPORT_W) cameraX = -(VIEWPORT_W - MAP_WIDTH) / 2;
            if (MAP_HEIGHT < SCREEN_H) cameraY = -(SCREEN_H - MAP_HEIGHT) / 2;
            if (gameState === 'INTRO') { if (cameraY < -300) cameraY = -300; }
        }
        function randomWind() { wind = parseFloat(((Math.random() * 10) - 5).toFixed(1)); }

        function spawnSupplyDrop() {
            let offset = (100 + Math.random() * 100) * (Math.random() < 0.5 ? 1 : -1);
            let dropX = player.x + offset; dropX = Math.max(BRIDGE_START + 50, Math.min(BRIDGE_END - 50, dropX));
            const newDrop = new SupplyDrop(dropX);
            supplyDrops.push(newDrop); activeSupplyDrop = newDrop;
            addChatLog("Hệ thống", "Chi viện đang tới!");
        }

        // === [REFACTORED] SWITCH TURN - DELEGATES CLEANUP TO TANK ===
        function switchTurn() {
            if (gameState === 'ENDED') { stopTimer(); SoundManager.stopBGM(); return; }

            if (turn === 'PLAYER_SHOOTING') {
                
                // --- TANK CLEANUP TRIGGER ---
                player.onTurnEnd();
                // -----------------------------

                if (player.extraShot) {
                    player.extraShot = false; turn = 'PLAYER'; player.moveEnergy = MAX_MOVE_ENERGY; 
                    charging = false; currentPower = 0; keys = {}; startTimer();
                    showFloatingText("LƯỢT BẮN THÊM!", player.x, player.y - 80, '#2979ff'); updateUI(); return; 
                }

                if (ai.hp <= 0) endGame('YOU WIN', '#00e676');
                else {
                    turn = 'AI'; stopTimer(); player.damageBuff = false; 
                    if (!playerLandedHit) { let missTaunt = getSmartTaunt('MISS'); showFloatingText(missTaunt, ai.x, ai.y - 90, '#000', true); addChatLog("Máy", missTaunt); }
                    setTimeout(aiMovePhase, 1000);
                }
            } else {
                if (player.hp <= 0) endGame('GAME OVER', '#ff5252');
                else {
                    turn = 'PLAYER'; player.moveEnergy = MAX_MOVE_ENERGY; 
                    charging = false; currentPower = 0; keys = {}; SoundManager.stopCharge();
                    randomWind(); startTimer();
                }
            }
            updateUI();
        }

        function aiMovePhase() {
            if (isPaused) { setTimeout(aiMovePhase, 500); return; } 
            if (Math.random() > 0.8) { aiLogic(); return; }
            let dir = Math.random() < 0.6 ? -1 : 1; let steps = Math.floor(Math.random() * 30) + 10; let count = 0;
            let moveInterval = setInterval(() => {
                if (isPaused) return; 
                let nextX = ai.x + (dir * 2);
                if (nextX > BRIDGE_START + 25 && nextX < BRIDGE_END - 25) { ai.move(dir); }
                else { clearInterval(moveInterval); aiLogic(); return; }
                count++; if (count >= steps) { clearInterval(moveInterval); setTimeout(aiLogic, 500); }
            }, 50);
        }

        function endGame(msg, color) { gameState = 'ENDED'; stopTimer(); elEndMsg.innerText = msg; elEndMsg.style.color = color; elEndScreen.classList.remove('hidden'); SoundManager.stopBGM(); }
        
        function createExplosion(x, y, count, type) {
            if (type === 'fire') { particles.push(new Particle(x, y, 'shockwave')); }
            for (let i = 0; i < count; i++) {
                let pType = (Math.random() < 0.3) ? 'smoke' : type; let speed = (Math.random() * 4) + 2;
                particles.push(new Particle(x, y, pType, { vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed, life: 1.0 + Math.random() * 0.5, decay: 0.03 + Math.random() * 0.02, size: Math.random() * 8 + 2 }));
            }
            if (type === 'fire') { for (let i = 0; i < 10; i++) { particles.push(new Particle(x, y, 'spark', { vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10 - 2, life: 0.8, size: 2 })); } }
        }

        // === [REFACTORED] GLOBAL CHECK COLLISION (SIMPLIFIED) ===
        function checkCollision() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let hit = false;
                let shooter = (turn.includes('PLAYER')) ? player : ai;
                let potentialTargets = [player, ai];

                if (b.y >= GROUND_Y + 10) hit = true; 
                else if (b.y > MAP_HEIGHT) bullets.splice(i, 1);
                
                if (!hit) {
                    for (let target of potentialTargets) {
                        if (target.hp <= 0) continue; 
                        let hitDistX = 25 * target.scale; let hitDistY = 30 * target.scale;
                        
                        if (Math.abs(b.x - target.x) < hitDistX && Math.abs(b.y - target.y) < hitDistY) {
                            hit = true;
                            if (target === ai && shooter === player) playerLandedHit = true;
                            
                            if (target === player && playerShieldActive) { 
                                showFloatingText("ĐỠ ĐÒN!", target.x, target.y - 80, '#00ffff'); 
                                playerShieldActive = false; createExplosion(target.x, target.y, 15, 'smoke'); 
                            } else {
                                // --- DELEGATE TO BULLET ---
                                b.handleCollision(target, shooter);
                                // --------------------------
                            }

                            if (target.hp <= 0 && gameState !== 'ENDED') {
                                if (target === player) endGame('GAME OVER', '#ff5252'); else endGame('YOU WIN', '#00e676'); 
                            }
                            break; 
                        }
                    }
                }
                
                for (let j = supplyDrops.length - 1; j >= 0; j--) {
                    let s = supplyDrops[j];
                    if (!s.isFalling && Math.abs(b.x - s.x) < 20 && Math.abs(b.y - s.y) < 20) {
                        hit = true; createExplosion(s.x, s.y, 20, 'fire'); showFloatingText("HÀNG BỊ HỦY!", s.x, s.y - 40, '#ff3d00'); supplyDrops.splice(j, 1);
                    }
                }

                if (hit) { 
                    if (b.y >= GROUND_Y + 10) { b.onHit(null); SoundManager.playExplosion(); }
                    bullets.splice(i, 1); 
                } else if (b.isDead) { bullets.splice(i, 1); }
            }
        }

        function showFloatingText(txt, x, y, c, isChat = false) { floatingTexts.push({ text: txt, x: x, y: y, color: c, life: isChat ? 400 : 150, maxLife: isChat ? 400 : 150, isChat: isChat }); }
        function addChatLog(name, text, isSpecial = false) {
            elChatHistory.style.display = 'flex'; const div = document.createElement('div'); div.className = 'chat-item';
            let nameHtml = `<span class="chat-name">${name}:</span>`; let contentHtml = isSpecial ? `<span class="chat-system ${text === 'SKILL HỦY DIỆT!' ? '' : 'chat-finish'}">${text}</span>` : text;
            div.innerHTML = nameHtml + contentHtml; elChatHistory.appendChild(div); if (elChatHistory.children.length > 4) { elChatHistory.removeChild(elChatHistory.firstChild); }
        }

        const TAUNTS = {
            'DỄ': ["Bé yêu đỡ lấy!", "Nhẹ thôi nhé!", "Trúng nè hihi!", "Đừng khóc nha!", "Ahihi đồ ngốc!", "Cẩn thận vỡ đầu!", "Đau tí thôi à.", "Chạy đi đâu con sâu?", "Gà quá đi à!", "Nhìn anh biểu diễn nè."],
            'KHÓ': ["Mày Xong Rồi!", "Chạy đi đâu?", "Ăn đạn đi cưng!", "Non lắm!", "Về vườn đi em!", "Tuổi gì solo?", "Ngắm gà hóa cuốc à?", "Một vé về làng!", "Khóc to lên!", "Đỡ hộ cái!"],
            'BẤT LỰC': ["Sao mà đỡ được!", "Tuyệt vọng chưa?", "Về tập thêm đi!", "Game là dễ!", "Chấp 2 tay luôn!", "Hủy diệt thế giới!", "Biết bố là ai không?", "Niệm thần chú đi!", "Sợ chưa con trai?", "Cảm giác bất lực chưa?"],
            'MISS': ["Bắn chim hả?", "Mù à cưng?", "Gà thế!", "Lêu lêu bắn hụt!", "Ngắm bằng chân à?", "Còn non lắm!", "Về tập thêm đi!", "Sợ run tay à?", "Chả trúng tí nào!", "Ha ha quê chưa?"],
            'FINISH': ["An nghỉ nhé!", "Vĩnh biệt!", "Quá yếu đuối!", "Game over baby!", "Về thành dưỡng sức đi!", "Một phát lên bảng!", "Hẹn kiếp sau nhé!", "Kết thúc!", "Bye bye cưng!", "EZ Game!"]
        };
        let chatPools = { 'DỄ': [], 'KHÓ': [], 'BẤT LỰC': [], 'MISS': [], 'FINISH': [] };
        function getSmartTaunt(category) {
            if (!chatPools[category] || chatPools[category].length === 0) { chatPools[category] = [...TAUNTS[category]]; }
            let randIndex = Math.floor(Math.random() * chatPools[category].length); return chatPools[category].splice(randIndex, 1)[0];
        }
        function aiLogic() {
            if (gameState === 'ENDED' || isPaused) { if (isPaused) setTimeout(aiLogic, 500); return; }
            let power = 100; let target = player; let aimMessage = "";
            let cratesOnGround = supplyDrops.filter(s => !s.isFalling);
            if (cratesOnGround.length > 0) {
                let targetCrate = cratesOnGround[0]; let testAngle = calculateFiringAngle(ai, targetCrate, power);
                if (testAngle !== null) { target = targetCrate; aimMessage = "Không ăn thì để tao phá!"; }
            }

            let perfectAngle = calculateFiringAngle(ai, target, power);
            let accuracyThreshold = Math.random() * (aiAccuracyMax - aiAccuracyMin) + aiAccuracyMin; 
            let isHit = Math.random() < accuracyThreshold;
            let finalAngle;

            if (perfectAngle !== null) {
                if (isHit) { finalAngle = perfectAngle; let tauntMsg = aimMessage !== "" ? aimMessage : getSmartTaunt(currentModeName); showFloatingText(tauntMsg, ai.x, ai.y - 90, '#000', true); addChatLog("Máy", tauntMsg); } 
                else { let deviation = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1); finalAngle = perfectAngle + deviation; }
            } else { finalAngle = 180 - (Math.random() * 30 + 20); }

            ai.angle = finalAngle; turn = 'AI_SHOOTING';
            let newBullets = [];
            if (currentModeName === 'BẤT LỰC' && ai.hp < (ai.maxHp * 0.5) && Math.random() < 0.5 && target === player) {
                const skillMsg = "SKILL HỦY DIỆT!"; showFloatingText(skillMsg, ai.x, ai.y - 120, '#d500f9', true); addChatLog("Hệ thống", skillMsg, true);
                newBullets = ai.fireSkill1(power, wind);
            } else { newBullets = ai.fireNormal(power, wind); }
            bullets.push(...newBullets);
        }
        function calculateFiringAngle(shooter, target, power) {
            let bestAngle = null; let minDistance = 9999;
            for (let a = 10; a <= 89; a += 0.5) {
                let testAngle = 180 - a; let hit = simulateTrajectory(shooter, target, testAngle, power);
                if (hit.success) { return testAngle; }
                if (hit.distance < minDistance) { minDistance = hit.distance; bestAngle = testAngle; }
            } return bestAngle;
        }
        function simulateTrajectory(shooter, target, angle, p) {
            const rad = angle * Math.PI / 180; let sx = shooter.x, sy = shooter.y - 14;
            let vx = Math.cos(rad) * (p * SPEED_CONSTANT); let vy = -Math.sin(rad) * (p * SPEED_CONSTANT); let minD = 9999;
            for (let i = 0; i < 1000; i++) {
                vx += wind * WIND_FACTOR; vy += GRAVITY; sx += vx; sy += vy;
                let dx = sx - target.x; let dy = sy - target.y; let d = Math.sqrt(dx * dx + dy * dy);
                if (d < 30) return { success: true, distance: 0 };
                if (d < minD) minD = d; if (sy > GROUND_Y + 50) break;
            } return { success: false, distance: minD };
        }
         function drawAimGuide() {
            // 1. Kiểm tra điều kiện cơ bản
            if (turn !== 'PLAYER' || gameState !== 'PLAYING') return;

            // 2. Cấu hình độ dài đường ngắm
            // Nếu dùng Skill 2 (Aim xa) -> Vẽ dài (300 điểm)
            // Nếu bình thường -> Vẽ ngắn (25 điểm - đoạn nét đứt gợi ý)
            let isLongPath = (activeSkill === 2);
            let drawSteps = isLongPath ? 300 : 25; 

            // 3. [QUAN TRỌNG] Luôn tính toán dựa trên FULL LỰC (100)
            // Điều này giúp đường ngắm luôn đúng hướng của quỹ đạo chuẩn, không bị "xìu" xuống
            let simPower = 100; 

            // 4. Gọi hàm tính toán vật lý từ class xe hiện tại
            // Lưu ý: Ta truyền vào tham số thứ 3 là 'drawSteps' để tối ưu, 
            // hàm calculateTrajectory sẽ chỉ tính toán bấy nhiêu điểm thôi.
            
            // (Chúng ta cần sửa nhẹ calculateTrajectory để nhận tham số steps tùy biến, xem bên dưới)
            let trajectory = player.calculateTrajectory(simPower, wind, drawSteps);
            let points = trajectory.points;

            if (points.length < 2) return;

            ctx.save();
            ctx.translate(player.x, player.y);

            // 5. Style vẽ (Nét đứt hoặc Gradient)
            if (activeSkill === 2) {
                // Skill 2: Vẽ dây dài, màu mè đẹp
                let grad = ctx.createLinearGradient(points[0].x, points[0].y, points[points.length-1].x, points[points.length-1].y);
                grad.addColorStop(0, player.color); 
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.strokeStyle = grad;
                ctx.setLineDash([]); // Nét liền
                ctx.lineWidth = 2;
            } else {
                // Bình thường: Nét đứt trắng ngắn gọn
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; 
                ctx.setLineDash([3, 4]); // Nét đứt thưa hơn chút cho dễ nhìn
                ctx.lineWidth = 2;
            }

            // 6. Thực hiện vẽ nối điểm
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.restore();
        }
        function drawEnvironment() {
            let grad = ctx.createLinearGradient(0, 0, 0, SCREEN_H); grad.addColorStop(0, '#87CEEB'); grad.addColorStop(0.6, '#B0E0E6'); grad.addColorStop(1, '#E0F7FA'); ctx.fillStyle = grad; 
            ctx.fillRect(0, 0, VIEWPORT_W, SCREEN_H); 
        }
        function drawWorldElements() {
            const bridgeH = 25; ctx.fillStyle = '#444';
            for (let bx = BRIDGE_START + 100; bx < BRIDGE_END; bx += 200) { if (bx - cameraX > -50 && bx - cameraX < VIEWPORT_W + 50) ctx.fillRect(bx - 10, GROUND_Y + bridgeH, 20, MAP_HEIGHT - GROUND_Y); }
            ctx.fillStyle = '#3a3a3a'; ctx.fillRect(BRIDGE_START, GROUND_Y, BRIDGE_END - BRIDGE_START, bridgeH);
            ctx.strokeStyle = '#222'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(BRIDGE_START, GROUND_Y); ctx.lineTo(BRIDGE_END, GROUND_Y); ctx.moveTo(BRIDGE_START, GROUND_Y + bridgeH); ctx.lineTo(BRIDGE_END, GROUND_Y + bridgeH);
            for (let i = BRIDGE_START; i < BRIDGE_END; i += 30) { if (i - cameraX > -50 && i - cameraX < VIEWPORT_W + 50) { ctx.moveTo(i, GROUND_Y); ctx.lineTo(i + 15, GROUND_Y + bridgeH); ctx.lineTo(i + 30, GROUND_Y); } } ctx.stroke();
            ctx.fillStyle = '#DDD'; ctx.fillRect(BRIDGE_START, GROUND_Y - 5, BRIDGE_END - BRIDGE_START, 4); ctx.fillStyle = '#999'; for (let r = BRIDGE_START; r <= BRIDGE_END; r += 20) { if (r - cameraX > -10 && r - cameraX < VIEWPORT_W + 10) ctx.fillRect(r, GROUND_Y - 5, 2, 4); }
            let wStart = Math.floor(cameraX / 10) * 10 - 20; if (wStart < 0) wStart = 0; let wEnd = wStart + VIEWPORT_W + 40; if (wEnd > MAP_WIDTH) wEnd = MAP_WIDTH;
            ctx.globalAlpha = 0.6; ctx.fillStyle = '#0288D1'; ctx.beginPath(); ctx.moveTo(wStart, MAP_HEIGHT); for (let i = wStart; i <= wEnd; i += 10) ctx.lineTo(i, (GROUND_Y + 50) + Math.sin(i * 0.01 + waterOffset) * 10); ctx.lineTo(wEnd, MAP_HEIGHT); ctx.fill();
            ctx.globalAlpha = 0.5; ctx.fillStyle = '#4FC3F7'; ctx.beginPath(); ctx.moveTo(wStart, MAP_HEIGHT); for (let i = wStart; i <= wEnd; i += 10) ctx.lineTo(i, (GROUND_Y + 60) + Math.sin(i * 0.015 + waterOffset + 1) * 8); ctx.lineTo(wEnd, MAP_HEIGHT); ctx.fill(); ctx.globalAlpha = 1.0;
        }

        function gameLoop() {
            if (gameState !== 'ENDED' && !isPaused) {
                waterOffset += 0.05; clouds.forEach(c => c.update());
                
                if (gameState === 'INTRO') {
                    let pLanded = player.updateParachute(); let aLanded = ai.updateParachute();
                    let targetCamX = player.x - VIEWPORT_W / 2; let targetCamY = player.y - SCREEN_H / 2;
                    cameraX += (targetCamX - cameraX) * 0.1; cameraY += (targetCamY - cameraY) * 0.1; clampCamera();
                    if (pLanded && aLanded) { 
                        gameState = 'PLAYING'; SoundManager.stopWind(); 
                        if (turn === 'PLAYER') { startTimer(); showFloatingText("BẮT ĐẦU!", player.x, player.y - 80, '#00e676'); }
                    }
                } else if (gameState === 'PLAYING') {
                    if (activeSupplyDrop) {
                        let targetCamX = activeSupplyDrop.x - VIEWPORT_W / 2; let targetCamY = activeSupplyDrop.y - SCREEN_H / 2; 
                        cameraX += (targetCamX - cameraX) * 0.1; cameraY += (targetCamY - cameraY) * 0.1; clampCamera();
                    } else {
                        // --- [NEW] LOGIC FILTERING SATELLITE ---
                        if (bullets.length > 0) {
                            bullets.forEach(b => b.update()); checkCollision();
                        }
                        // Lọc các đạn thực sự đang bay (bỏ qua vệ tinh đứng yên)
                        let activeBullets = bullets.filter(b => b.shouldCameraTrack);

                        if (activeBullets.length > 0) { 
                            let b = activeBullets[0]; let targetCamX = b.x - VIEWPORT_W / 2; let targetCamY = b.y - SCREEN_H / 2; 
                            cameraX += (targetCamX - cameraX) * 0.1; cameraY += (targetCamY - cameraY) * 0.1; clampCamera(); 
                        } else if (turn.includes('SHOOTING') && particles.length === 0) {
                            switchTurn(); 
                            let targetX = (turn === 'PLAYER') ? player.x - 200 : ai.x - (VIEWPORT_W - 200); let targetY = MAP_HEIGHT - SCREEN_H; 
                            cameraX += (targetX - cameraX) * 0.05; cameraY += (targetY - cameraY) * 0.05; clampCamera();
                        }
                    }
                    supplyDrops.forEach((s, i) => { s.update(); if (s.intercepted && !s.isFalling) supplyDrops.splice(i, 1); });
                    if (turn === 'PLAYER' && !activeSupplyDrop) {
                        if (keys['ArrowLeft']) player.move(-1); if (keys['ArrowRight']) player.move(1); 
                        if (keys['ArrowUp']) player.adjustAngle(1); if (keys['ArrowDown']) player.adjustAngle(-1);
                        if (charging) { SoundManager.startCharge(); SoundManager.updateCharge(currentPower); currentPower = Math.min(100, currentPower + 1.5); elPowerBar.style.width = currentPower + '%'; } else { SoundManager.stopCharge(); }
                        updateUI();
                    }
                }
                particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
                floatingTexts.forEach((f, i) => { f.y -= f.isChat ? 0.05 : 0.5; f.life--; if (f.life <= 0) floatingTexts.splice(i, 1); });
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); ctx.scale(dpr * GAME_SCALE, dpr * GAME_SCALE);
            drawEnvironment(); clouds.forEach(c => c.draw()); 
            ctx.save(); ctx.translate(-cameraX, -cameraY); 
            drawAimGuide(); drawWorldElements(); supplyDrops.forEach(s => s.draw());
            if(player) player.draw(ctx);
            if (playerShieldActive && player) { 
                ctx.save(); ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff'; 
                ctx.beginPath(); ctx.arc(player.x, player.y - 20, 35, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.fill(); ctx.restore(); 
            }
            if(ai) ai.draw(ctx); 
            bullets.forEach(b => b.draw(ctx)); particles.forEach(p => p.draw());
            floatingTexts.forEach(ft => {
                ctx.save(); let alpha = 1; if (ft.life < 30) alpha = ft.life / 30; ctx.globalAlpha = alpha; 
                if (ft.isChat) {
                    ctx.font = 'bold 13px Tahoma'; let textWidth = ctx.measureText(ft.text).width; let padding = 10; let boxW = textWidth + padding * 2; let boxH = 30; let boxX = ft.x - boxW / 2; let boxY = ft.y - 20;
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(ft.x, boxY + boxH); ctx.lineTo(ft.x - 5, boxY + boxH + 6); ctx.lineTo(ft.x + 5, boxY + boxH + 6); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(boxX + 5, boxY); ctx.lineTo(boxX + boxW - 5, boxY); ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + 5); ctx.lineTo(boxX + boxW, boxY + boxH - 5); ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - 5, boxY + boxH); ctx.lineTo(boxX + 5, boxY + boxH); ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - 5); ctx.lineTo(boxX, boxY + 5); ctx.quadraticCurveTo(boxX, boxY, boxX + 5, boxY); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = ft.color === '#d500f9' ? '#d500f9' : '#000'; ctx.fillText(ft.text, boxX + padding, boxY + 19);
                } else { ctx.font = 'bold 18px Arial'; ctx.lineWidth = 3; ctx.strokeStyle = 'black'; ctx.strokeText(ft.text, ft.x, ft.y); ctx.fillStyle = ft.color; ctx.fillText(ft.text, ft.x, ft.y); }
                ctx.restore();
            });
            ctx.restore(); ctx.restore(); drawMinimap(); requestAnimationFrame(gameLoop);
        }
        function gameLoop() {
            if (gameState !== 'ENDED' && !isPaused) {
                waterOffset += 0.05; clouds.forEach(c => c.update());
                
                if (gameState === 'INTRO') {
                    let pLanded = player.updateParachute(); let aLanded = ai.updateParachute();
                    let targetCamX = player.x - VIEWPORT_W / 2; let targetCamY = player.y - SCREEN_H / 2;
                    cameraX += (targetCamX - cameraX) * 0.1; cameraY += (targetCamY - cameraY) * 0.1; clampCamera();
                    if (pLanded && aLanded) { 
                        gameState = 'PLAYING'; SoundManager.stopWind(); 
                        if (turn === 'PLAYER') { startTimer(); showFloatingText("BẮT ĐẦU!", player.x, player.y - 80, '#00e676'); }
                    }
                } else if (gameState === 'PLAYING') {
                    if (activeSupplyDrop) {
                        let targetCamX = activeSupplyDrop.x - VIEWPORT_W / 2; let targetCamY = activeSupplyDrop.y - SCREEN_H / 2; 
                        cameraX += (targetCamX - cameraX) * 0.1; cameraY += (targetCamY - cameraY) * 0.1; clampCamera();
                    } else {
                        if (bullets.length > 0) {
                            bullets.forEach(b => b.update()); checkCollision();
                        }
                        
                        // === [FIX LOGIC CAMERA] ===
                        // Chỉ bám theo đạn thực sự đang bay trên màn hình
                        // Loại bỏ: Vệ tinh (SATELLITE) VÀ Đạn đang chờ (activationDelay > 0 hoặc y < -1000)
                        let activeBullets = bullets.filter(b => {
                            if (b.type === 'SATELLITE') return false;
                            if (b.activationDelay && b.activationDelay > 0) return false; // Đạn súng máy chưa bắn
                            if (b.y < -1000) return false; // Đạn bị giấu quá xa
                            return true;
                        });

                        if (activeBullets.length > 0) { 
                            // Bám theo viên đạn hợp lệ đầu tiên
                            let b = activeBullets[0]; 
                            let targetCamX = b.x - VIEWPORT_W / 2; 
                            let targetCamY = b.y - SCREEN_H / 2; 
                            cameraX += (targetCamX - cameraX) * 0.1; 
                            cameraY += (targetCamY - cameraY) * 0.1; 
                            clampCamera(); 
                        } else if (turn.includes('SHOOTING') && particles.length === 0) {
                            // Nếu không còn đạn bay -> Chuyển lượt
                            // Lưu ý: Dù activeBullets rỗng, nhưng bullets gốc vẫn có thể còn (Vệ tinh), 
                            // nên switchTurn sẽ tự lo liệu việc dọn dẹp vệ tinh.
                            switchTurn(); 
                            let targetX = (turn === 'PLAYER') ? player.x - 200 : ai.x - (VIEWPORT_W - 200); let targetY = MAP_HEIGHT - SCREEN_H; 
                            cameraX += (targetX - cameraX) * 0.05; cameraY += (targetY - cameraY) * 0.05; clampCamera();
                        }
                        // ==========================
                    }
                    supplyDrops.forEach((s, i) => { s.update(); if (s.intercepted && !s.isFalling) supplyDrops.splice(i, 1); });
                    if (turn === 'PLAYER' && !activeSupplyDrop) {
                        if (keys['ArrowLeft']) player.move(-1); if (keys['ArrowRight']) player.move(1); 
                        if (keys['ArrowUp']) player.adjustAngle(1); if (keys['ArrowDown']) player.adjustAngle(-1);
                        if (charging) { SoundManager.startCharge(); SoundManager.updateCharge(currentPower); currentPower = Math.min(100, currentPower + 1.5); elPowerBar.style.width = currentPower + '%'; } else { SoundManager.stopCharge(); }
                        updateUI();
                    }
                }
                particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
                floatingTexts.forEach((f, i) => { f.y -= f.isChat ? 0.05 : 0.5; f.life--; if (f.life <= 0) floatingTexts.splice(i, 1); });
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); ctx.scale(dpr * GAME_SCALE, dpr * GAME_SCALE);
            drawEnvironment(); clouds.forEach(c => c.draw()); 
            ctx.save(); ctx.translate(-cameraX, -cameraY); 
            drawAimGuide(); drawWorldElements(); supplyDrops.forEach(s => s.draw());
            if(player) player.draw(ctx);
            if (playerShieldActive && player) { 
                ctx.save(); ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff'; 
                ctx.beginPath(); ctx.arc(player.x, player.y - 20, 35, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.fill(); ctx.restore(); 
            }
            if(ai) ai.draw(ctx); 
            bullets.forEach(b => b.draw(ctx)); particles.forEach(p => p.draw());
            floatingTexts.forEach(ft => {
                ctx.save(); let alpha = 1; if (ft.life < 30) alpha = ft.life / 30; ctx.globalAlpha = alpha; 
                if (ft.isChat) {
                    ctx.font = 'bold 13px Tahoma'; let textWidth = ctx.measureText(ft.text).width; let padding = 10; let boxW = textWidth + padding * 2; let boxH = 30; let boxX = ft.x - boxW / 2; let boxY = ft.y - 20;
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(ft.x, boxY + boxH); ctx.lineTo(ft.x - 5, boxY + boxH + 6); ctx.lineTo(ft.x + 5, boxY + boxH + 6); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(boxX + 5, boxY); ctx.lineTo(boxX + boxW - 5, boxY); ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + 5); ctx.lineTo(boxX + boxW, boxY + boxH - 5); ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - 5, boxY + boxH); ctx.lineTo(boxX + 5, boxY + boxH); ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - 5); ctx.lineTo(boxX, boxY + 5); ctx.quadraticCurveTo(boxX, boxY, boxX + 5, boxY); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = ft.color === '#d500f9' ? '#d500f9' : '#000'; ctx.fillText(ft.text, boxX + padding, boxY + 19);
                } else { ctx.font = 'bold 18px Arial'; ctx.lineWidth = 3; ctx.strokeStyle = 'black'; ctx.strokeText(ft.text, ft.x, ft.y); ctx.fillStyle = ft.color; ctx.fillText(ft.text, ft.x, ft.y); }
                ctx.restore();
            });
            ctx.restore(); ctx.restore(); drawMinimap(); requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            if(!player) return;
            elWind.innerText = (wind > 0 ? '→ ' : '← ') + Math.abs(wind); elAngle.innerText = Math.floor(player.angle) + '°'; elHp.innerText = Math.max(0, player.hp); elMoveBar.style.width = (player.moveEnergy / MAX_MOVE_ENERGY * 100) + '%';
            elModeText.innerText = currentModeName; elTurnText.innerText = turn.includes('PLAYER') ? 'BẠN' : 'MÁY'; elTurnText.style.color = turn.includes('PLAYER') ? '#00d2ff' : '#ff5722';
            if (turn === 'PLAYER' && gameState === 'PLAYING') { elTimerText.innerText = timeLeft + 's'; if (timeLeft <= 5) elTimerText.classList.add('timer-warning'); else elTimerText.classList.remove('timer-warning'); } else { elTimerText.innerText = '--'; elTimerText.classList.remove('timer-warning'); }
            if (!charging) elPowerBar.style.width = currentPower + '%';
            const controlsArea = document.querySelector('.controls-area'); const actionContainer = document.querySelector('.action-container');
            if (turn === 'PLAYER' && gameState === 'PLAYING') { controlsArea.style.opacity = '1'; controlsArea.style.pointerEvents = 'auto'; actionContainer.style.opacity = '1'; actionContainer.style.pointerEvents = 'auto'; } else { controlsArea.style.opacity = '0.5'; controlsArea.style.pointerEvents = 'none'; actionContainer.style.opacity = '0.5'; actionContainer.style.pointerEvents = 'none'; }
            
            if (skill1Used) { btnSkill1.classList.remove('unlocked', 'active'); btnSkill1.classList.add('used'); } else if (player.hp < 80) { btnSkill1.classList.add('unlocked'); } else { btnSkill1.classList.remove('unlocked', 'active'); if (activeSkill === 1) activeSkill = null; }
            if (skill2Used) { btnSkill2.classList.remove('unlocked', 'active'); btnSkill2.classList.add('used'); } else if (player.hp < 60) { btnSkill2.classList.add('unlocked'); } else { btnSkill2.classList.remove('unlocked', 'active'); if (activeSkill === 2) activeSkill = null; }
            if (skill3Used) { btnSkill3.classList.remove('unlocked', 'active'); btnSkill3.classList.add('used'); } else if (player.hp < 40) { btnSkill3.classList.add('unlocked'); } else { btnSkill3.classList.remove('unlocked', 'active'); if (activeSkill === 3) activeSkill = null; }
            if (skill4Uses <= 0) { btnSkill4.classList.remove('unlocked', 'active'); btnSkill4.classList.add('used'); btnSkill4.querySelector('.skill-info').innerText = "Hết lượt"; } 
            else if (player.hp < 50) { btnSkill4.classList.add('unlocked'); btnSkill4.classList.remove('used'); btnSkill4.querySelector('.skill-info').innerText = `Tiếp Tế (Còn ${skill4Uses})`; } 
            else { btnSkill4.classList.remove('unlocked', 'active'); if (activeSkill === 4) activeSkill = null; }
            updateFireButtonVisuals();
        }
        function updateFireButtonVisuals() { if (activeSkill) { btnFire.classList.add('skill-active-mode'); btnFire.innerText = "CHIÊU!"; } else { btnFire.classList.remove('skill-active-mode'); btnFire.innerText = "BẮN"; } }

        canvas.addEventListener('mousedown', e => { if (isPaused) return; isDragging = true; startDragX = e.clientX; startDragY = e.clientY; initialCameraX = cameraX; initialCameraY = cameraY; canvas.style.cursor = 'grabbing'; });
        window.addEventListener('mousemove', e => { if (!isDragging) return; cameraX = initialCameraX - (e.clientX - startDragX) / GAME_SCALE; cameraY = initialCameraY - (e.clientY - startDragY) / GAME_SCALE; clampCamera(); });
        window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
        canvas.addEventListener('touchstart', e => { if (isPaused) return; isDragging = true; startDragX = e.touches[0].clientX; startDragY = e.touches[0].clientY; initialCameraX = cameraX; initialCameraY = cameraY; }, { passive: false });
        window.addEventListener('touchmove', e => { if (!isDragging) return; cameraX = initialCameraX - (e.touches[0].clientX - startDragX) / GAME_SCALE; cameraY = initialCameraY - (e.touches[0].clientY - startDragY) / GAME_SCALE; clampCamera(); }, { passive: false });
        window.addEventListener('touchend', () => isDragging = false);

        function handleStart(act) {
            if (isPaused || activeSupplyDrop) return; if (turn !== 'PLAYER' || gameState !== 'PLAYING') return;
            if (act !== 'fire') { keys[act] = true; } else if (gameState === 'PLAYING') { charging = true; currentPower = 0; }
        }
        function handleEnd(act) {
            if (isPaused || activeSupplyDrop) return; if (turn !== 'PLAYER' || gameState !== 'PLAYING') { charging = false; return; }
            if (act !== 'fire') { keys[act] = false; }
            else if (gameState === 'PLAYING') {
                charging = false; SoundManager.stopCharge();
                if (currentPower > 5) {
                    stopTimer(); playerLandedHit = false; turn = 'PLAYER_SHOOTING';
                    let newBullets = [];
                    if (activeSkill === 1) { newBullets = player.fireSkill1(currentPower, wind); skill1Used = true; }
                    else if (activeSkill === 2) { newBullets = player.fireSkill2(currentPower, wind); skill2Used = true; }
                    else if (activeSkill === 3) { newBullets = player.fireNormal(currentPower, wind); skill3Used = true; }
                    else { newBullets = player.fireNormal(currentPower, wind); }
                    bullets.push(...newBullets);
                    activeSkill = null; btnSkill1.classList.remove('active'); btnSkill2.classList.remove('active'); btnSkill3.classList.remove('active'); btnSkill4.classList.remove('active'); updateUI();
                } else { currentPower = 0; updateUI(); }
            }
        }
        function toggleSkill(skillNum, btnElement) {
            if (isPaused || activeSupplyDrop) return; if (turn !== 'PLAYER' || gameState !== 'PLAYING') return;
            if (!btnElement.classList.contains('unlocked') || btnElement.classList.contains('used')) return;
            playerShieldActive = false;
            if (skillNum === 4) { spawnSupplyDrop(); skill4Uses--; showFloatingText("GỌI TIẾP TẾ!", player.x, player.y - 80, '#fff'); updateUI(); return; }
            if (activeSkill === skillNum) { 
                activeSkill = null; btnElement.classList.remove('active'); 
                if (skillNum === 2) { for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i].type === 'SATELLITE') bullets.splice(i, 1); } }
            } else { 
                activeSkill = skillNum; btnSkill1.classList.remove('active'); btnSkill2.classList.remove('active'); btnSkill3.classList.remove('active'); btnSkill4.classList.remove('active'); btnElement.classList.add('active'); 
                if (activeSkill === 3) { playerShieldActive = true; showFloatingText("KHIÊN BẢO VỆ!", player.x, player.y - 80, '#00ffff'); }
                if (activeSkill === 2 && player instanceof LaserTank) { player.deploySatellite(); showFloatingText("VỆ TINH SẴN SÀNG!", player.x, player.y - 80, '#d500f9'); }
            }
            updateUI();
        }

        btnSkill1.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(1, btnSkill1); });
        btnSkill2.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(2, btnSkill2); });
        btnSkill3.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(3, btnSkill3); });
        btnSkill4.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(4, btnSkill4); });
        btnSkill1.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(1, btnSkill1); });
        btnSkill2.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(2, btnSkill2); });
        btnSkill3.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(3, btnSkill3); });
        btnSkill4.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(4, btnSkill4); });

        const mapBtn = { 'btn-left': 'ArrowLeft', 'btn-right': 'ArrowRight', 'btn-up': 'ArrowUp', 'btn-down': 'ArrowDown', 'btn-fire': 'fire' };
        Object.keys(mapBtn).forEach(id => {
            const el = document.getElementById(id); const action = mapBtn[id];
            const startAction = (e) => { if (e.cancelable) e.preventDefault(); e.stopPropagation(); handleStart(action); };
            const endAction = (e) => { if (e.cancelable) e.preventDefault(); e.stopPropagation(); handleEnd(action); };
            el.addEventListener('mousedown', startAction); el.addEventListener('touchstart', startAction, { passive: false });
            el.addEventListener('mouseup', endAction); el.addEventListener('touchend', endAction);
            el.addEventListener('mouseleave', (e) => { if (turn === 'PLAYER' && action === 'fire') { charging = false; currentPower = 0; SoundManager.stopCharge(); updateUI(); } else { endAction(e); } });
            el.addEventListener('touchcancel', endAction);
        });

        window.addEventListener('mouseup', () => { if (turn === 'PLAYER') { keys['ArrowLeft'] = false; keys['ArrowRight'] = false; keys['ArrowUp'] = false; keys['ArrowDown'] = false; } });
        window.addEventListener('contextmenu', e => e.preventDefault());
        init();
    </script>
</body>

</html>


